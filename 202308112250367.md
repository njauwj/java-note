[TOC]

## 一、Spring

### 什么是Spring

> 支持`IOC`和`AOP`的轻量级多模块Java开发框架
>
> Spring主要模块
>
> **Core Container**
>
> Spring 框架的核心模块，也可以说是基础模块，主要提供 IoC 依赖注入功能的支持。Spring 其他所有的功能基本都需要依赖于该模块，我们从上面那张 Spring 各个模块的依赖关系图就可以看出来。
>
> - **spring-core**：Spring 框架基本的核心工具类。
> - **spring-beans**：提供对 bean 的创建、配置和管理等功能的支持。
> - **spring-context**：提供对国际化、事件传播、资源加载等功能的支持。
> - **spring-expression**：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。
>
> **AOP**
>
> - **spring-aspects**：该模块为与 AspectJ 的集成提供支持。
> - **spring-aop**：提供了面向切面的编程实现。
> - **spring-instrument**：提供了为 JVM 添加代理（agent）的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文 件，就像这些文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限。
>
> **Data Access/Integration**
>
> - **spring-jdbc**：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。
> - **spring-tx**：提供对事务的支持。
> - **spring-orm**：提供对 Hibernate、JPA、iBatis 等 ORM 框架的支持。
> - **spring-oxm**：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。
> - **spring-jms** : 消息服务。自 Spring Framework 4.1 以后，它还提供了对 spring-messaging 模块的继承。
>
> **Spring Web**
>
> - **spring-web**：对 Web 功能的实现提供一些最基础的支持。
> - **spring-webmvc**：提供对 Spring MVC 的实现。
> - **spring-websocket**：提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。
> - **spring-webflux**：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步。
>
> ![Spring5.x主要模块](https://raw.githubusercontent.com/njauwj/java-note/master/202308082249362.png)

### 什么是Spring AOP

> 目的：面向切面编程，将那些与业务代码无关（例如日志，事务等），有着公共逻辑的代码抽离出来进行**复用**，减少重复代码。
>
> Spring AOP底层是基于`动态代理`的，被代理类实现了接口就会使用JDk动态代理，没有实现接口则会使用CGLib动态代理
>
> AOP设计的专业术语
>
> ![image-20230809211623291](https://raw.githubusercontent.com/njauwj/java-note/master/202308092116342.png)
>
> 通知的分类：
> 
>1. **前置通知（Before Advice）：** 在目标方法执行前执行的通知。常用于执行一些预处理操作，如参数验证、权限检查等。
> 2. **后置通知（After Advice）：** 在目标方法执行后执行的通知。不管目标方法是否抛出异常，后置通知都会执行。常用于资源的释放和清理工作。
>3. **返回通知（After Returning Advice）：** 在目标方法成功返回结果后执行的通知。可以访问目标方法的返回值。
> 4. **异常通知（After Throwing Advice）：** 在目标方法抛出异常后执行的通知。可以捕获和处理方法抛出的异常。
>5. **环绕通知（Around Advice）：** 最强大的通知类型，可以在目标方法的前后执行自定义的操作。需要显式调用目标方法，并可以控制是否继续执行目标方法。

### Spring AOP 和 AspectJ AOP 有什么区别？

> - Spring AOP 属于`运行时增强`，而 AspectJ 是`编译时增强`。
>
> - Spring AOP 基于`动态代理`(Proxying)，而 AspectJ 基于`字节码操作`(Bytecode Manipulation),并且需要使用自己的编译器（ajc）
> - Spring AOP**复用了AspectJ 的注解**，例如@Aspect，@Before等等，但仅仅只是复用了注解，底层还是动态代理的实现。
> - AspectJ 性能更好

### Spring动态代理

> https://www.cnblogs.com/tuyang1129/p/12878549.html
>
> 1. JDK动态代理：代理类与被代理类实现同一个接口，编写一个类实现`InvocationHandler`接口，重写回调函数`invoke`，也就是编写增强逻辑并通过反射调用目标方法，在通过Proxy.*newProxyInstance* 将这个类作为参数创建代理对象，代理对象调用方法时会触发回调函数invoke
>
>     优点：不需要添加依赖，
>
>     缺点：需要实现接口，没有在接口里被声明的方法无法被代理
>
> 2. CGLib动态代理：无需实现接口，直接操作字节码，继承目标类生成子类然后重写目标方法添加增强逻辑
>
>     优点：更加灵活，不需要反射调用，性能更好
>
>     缺点：需要引入第三方依赖，final类无法被代理，因为无法继承。private方法也无法被代理，因为无法重写。
>
> SpringBoot2.0之后默认使用的都是CGLib作为动态代理，可以配置文件设置
>
> ```yaml
> spring:
>   aop:
>     proxy-target-class: true #默认为true，开启的是CGLib
> ```

### Spring事务失效的场景

> 1. 捕获了异常，却没有抛出
> 2. 抛出了检查异常（IO异常），@Transactional默认只对 `Error` 和 `RuntimeException` 进行回滚
> 3. 事务方法不是public，Spring 为方法创建代理、添加事务通知、前提条件都是该方法是 public 的
> 4. 非事务方法直接调用事务方法，this调用事务是无法生效的，解决方案：使用代理对象调用

### Spring事务的传播特性

> 1. `PROPAGATION_REQUIRED`（默认）：存在事务则加入事务，不存在则创建新事务
> 2. `PROPAGATION_REQUIRES_NEW`：无论是否有事务，都创建一个新事务
> 3. `PROPAGATION_NESTED`：有事务则嵌套事务，外层事务提交了，嵌套事务才能被提交。没有事务就直接创建新事务了
> 4. `PROPAGATION_SUPPORTS`：存在事务则加入事务，否则就是非事务执行
> 5. `PROPAGATION_NOT_SUPPORTED`：有事务也将事务挂起，以非事务方法执行
> 6. `PROPAGATION_MANDATORY`：存在事务则加入事务，不存在事务直接抛异常
> 7. `PROPAGATION_NEVER`：当前存在事务则抛异常

### Spring是如何解决循环依赖问题的

> 循环依赖：循环依赖其实就是循环引用,也就是两个或两个以上的bean互相持有对方,最终形成闭环。比如A依赖于B,B依赖于A
>
> 循环依赖在spring中是允许存在，spring框架依据三级缓存已经解决了大部分的循环依赖
>
> ①一级缓存：单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象
>
> ②二级缓存：缓存早期的bean对象（生命周期还没走完）
>
> ③三级缓存：缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的，如果需要的代理对象就会创造代理对象
>
> ![image-20230604233127731](https://raw.githubusercontent.com/njauwj/java-note/master/image-20230604233127731.png)
>
> 无法处理的情况：构造方法内出现依赖
>
> ![image-20230604233303554](https://raw.githubusercontent.com/njauwj/java-note/master/image-20230604233303554.png)
>
> **原因**：由于bean的生命周期中构造函数是第一个执行的，spring框架并不能解决构造函数的的依赖注入
>
> **解决方案**：使用@Lazy进行懒加载，什么时候需要对象再进行bean对象的创建

### Spring IOC

> IOC（控制反转）：是一种思想，而并非具体的一个实现，Spring通过使用**Spring容器**来负责对象的创建和管理实现了IOC
>
> **为什么叫控制反转？**
>
> - **控制**：指的是对象创建（实例化、管理）的权力
>- **反转**：控制权交给外部环境（Spring 框架、IoC 容器）
> 
>![IoC 图解](https://raw.githubusercontent.com/njauwj/java-note/master/202308082300767.png)

### Spring框架中的Bean是线程安全的吗？

> Bean是否线程安全取决于Bean的`作用域`和`状态`
>
> `Prototype`每次获取都会创建新的Bean，不存在资源竞争问题，线程是安全的
>
> `singleton` 作用域下，IoC 容器中只有唯一的 bean 实例，可能会存在资源竞争问题（取决于 Bean 是否有状态）。如果这个 bean 是有状态的话，那就存在线程安全问题
>
> bean不是线程安全的，不过一般bean都是无状态的的service和dao，如果存在有状态的bean需要开发时自行考虑。
>
> - **有状态**：就是有数据存储功能，有**可变的成员变量**。
> - **无状态**：就是不会保存数据。

### Springboot的自动装配原理

> 1, 在Spring Boot项目中的引导类上有一个注解@SpringBootApplication，这个注解是对三个注解进行了封装，分别是：
>
> @SpringBootConfiguration：声明这是一个配置类
>
> @EnableAutoConfiguration
>
> @ComponentScan：默认扫描启动类所在包及其子包下的bean
>
> 2, 其中@EnableAutoConfiguration是实现自动化配置的核心注解。 该注解通过@Import注解导入对应的配置选择器。
>
> 内部就是读取了该项目和该项目引用的Jar包的的classpath路径下META-INF/spring.factories文件中的所配置的类的全类名。 在这些配置类中所定义的Bean会根据条件注解所指定的条件来决定是否需要将其导入到Spring容器中。
>
> 3, 条件判断会有像@ConditionalOnClass这样的注解，判断是否有对应的class文件，如果有则加载该类，把这个配置类的所有的Bean放入spring容器中使用。

### Spring中bean的生命周期

> https://juejin.cn/post/6966158157202587662#heading-26
>
> 1. **`实例化`（Instantiation）**：在这个阶段，容器根据配置创建 Bean 的实例。这是通过调用 Bean 构造函数或工厂方法来完成的。
>2. **`属性赋值`（Population）**：在创建 Bean 实例后，容器会将配置的属性值或引用注入到 Bean 中，包括基本类型、引用类型以及其他 Bean。
> 3. **`初始化`（Initialization）**：在属性赋值完成后，容器会调用初始化方法（如 `@PostConstruct` 注解标记的方法或实现了 `InitializingBean` 接口的方法）来进行一些初始化操作。
>4. **`使用`（In Use）**：此阶段表示 Bean 已经完全初始化，可以被容器和其他 Bean 使用。
> 5. **`销毁`（Destruction）**：在容器关闭或 Bean 不再需要时，容器会调用销毁方法（如 `@PreDestroy` 注解标记的方法或实现了 `DisposableBean` 接口的方法）来执行清理操作。
>
> ![Bean生命周期](https://raw.githubusercontent.com/njauwj/java-note/master/202308092002321.webp)

### Spring 框架中都用到了哪些设计模式？

> https://juejin.cn/post/6844903849849962509
>
> 1. `工厂模式`：Spring使用工厂模式可以通过 `BeanFactory` 或 `ApplicationContext` 创建 bean 对象。
> 2. `单例模式`：Spring的bean默认创建就是单例的
> 3. `代理模式`：使用动态代理实现AOP
> 3. `适配器模式`：SpringMVC也用到了**HandlerAdaptor**适配Controller

### SpringMVC的核心组件

> **`DispatcherServlet`**：**核心的中央处理器**，负责接收请求、分发，并给予客户端响应。
>
> **`HandlerMapping`**：**处理器映射器**，根据 uri 去匹配查找能处理的 `Handler` ，并会将请求涉及到的拦截器和 `Handler` 一起封装。
>
> **`HandlerAdapter`**：**处理器适配器**，根据 `HandlerMapping` 找到的 `Handler` ，适配执行对应的 `Handler`；
>
> **`Handler`**：**请求处理器（Controller）**，处理实际请求的处理器。
>
> **`ViewResolver`**：**视图解析器**，根据 `Handler` 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 `DispatcherServlet` 响应客户端

### SpringMVC执行流程

> 1. 前后端不分离
>
>     ![image-20230605230837897](https://raw.githubusercontent.com/njauwj/java-note/master/image-20230605230837897.png)
>
>     ![image-20230605230822835](https://raw.githubusercontent.com/njauwj/java-note/master/202308082245274.png)
>
> 2. 前后端分离
>
>     ![image-20230605230900715](https://raw.githubusercontent.com/njauwj/java-note/master/202308082245945.png)
>
>     ![image-20230605230913883](https://raw.githubusercontent.com/njauwj/java-note/master/202308082245882.png)
>
>     

### Spring，SpringMVC，SpringBoot的区别

> Spring MVC 是 Spring 框架的 Web 模块，专门用于开发 Web 应用。它采用了 MVC（模型-视图-控制器）架构，将应用划分为模型（业务逻辑）、视图（用户界面）和控制器（请求处理），帮助开发者更好地组织和维护 Web 应用。
>
> Spring Boot 提供了约定大于配置的思想，减少了开发者的配置工作，同时提供了很多集成组件

### 将一个类声明为Bean的注解有哪些

> Bean：交给Spring容器管理的对象
>
> 1. **@Component：** 这是通用的组件注解，可以用来将一个类声明为 Spring 管理的 Bean。它是其他注解的基础。
> 2. **@Service：** 通常用于标识业务逻辑层的 Bean，相当于声明一个服务类。
> 3. **@Repository：** 通常用于标识数据访问层的 Bean，表示一个仓库或数据访问对象（DAO）。
> 4. **@Controller：** 用于标识控制器层的 Bean，表示一个 Spring MVC 控制器。
> 5. **@RestController：** 是@Controller和@ResponseBody的组合，用于标识控制器层的 Bean，并将返回结果直接作为响应体。
> 6. **@Configuration：** 用于标识配置类，通常配合@Bean一起使用，用来定义 Spring 容器中的 Bean。
> 7. **@ComponentScan：** 用于配置自动扫描的包路径，使得被注解的类能够被自动识别为 Bean。
> 8. **@Bean：** 通常在@Configuration类中使用，用来声明一个方法为 Bean。

### 注入 Bean 的注解有哪些？

> 1. **@Autowired：** 通过类型自动注入 Bean。**可以用在字段、构造方法、Setter 方法上**。可以配合 @Qualifier 注解指定具体的 Bean 名称。
> 2. **@Resource：** 通过名称自动注入 Bean。**可以用在字段、构造方法、Setter 方法上**。默认按照 Bean 的名称进行匹配，也可以通过 name 属性指定名称。
>
> 区别：
>
> - Autowired 是Spring提供的注解，Resource是JDK自带的注解
>
> - @Autowired默认先按byType进行匹配，如果发现找到多个bean，则又按照byName方式进行匹配，如果还有多个，则报出异常
>
>     ![img](https://raw.githubusercontent.com/njauwj/java-note/master/202308082316593.png)
>
> - **@Resource的装配顺序如下**
>
>     - 如果同时指定了name和type，流程如下：
>
>         ![img](https://raw.githubusercontent.com/njauwj/java-note/master/202308082318193.png)
>
>     - 如果指定了name，流程如下：
>
>         ![img](https://raw.githubusercontent.com/njauwj/java-note/master/202308082318665.png)
>
>     - 如果指定了type，流程如下：
>
>         ![img](https://raw.githubusercontent.com/njauwj/java-note/master/202308082319056.png)
>
>     - 如果既没有指定name，也没有指定type，流程如下：
>
>         ![img](https://raw.githubusercontent.com/njauwj/java-note/master/202308082319702.png)

### Bean的作用域有哪些

> 1. **`Singleton`（默认）：** 在整个 Spring 容器中只存在一个 Bean 实例。这是 Spring 的默认作用域。
> 2. **`Prototype`：** 每次从容器中获取该 Bean 时都会创建一个新的实例。
> 3. **Request：** 每个 HTTP 请求都会创建一个新的实例，适用于 Web 应用。
> 4. **Session：** 每个 HTTP Session 都会创建一个新的实例，适用于 Web 应用。
>
> 可以通过`@Scope`注解配置
>
> xml配置
>
> ```xml
> <bean id="..." class="..." scope="singleton"></bean>
> ```

## 二、JVM

### JVM垃圾回收时会导致程序阻塞吗

JVM在进行垃圾回收时，会导致程序暂停或阻塞，具体的表现形式取决于使用的垃圾回收算法和具体的实现。

在串行垃圾回收器和ParNew垃圾回收器中，垃圾回收时会暂停所有的用户线程，直到垃圾回收完成。这种暂停时间随着堆大小的增加而增加，严重影响应用程序的响应性和稳定性。

在CMS垃圾回收器中，垃圾回收时会通过多线程的方式进行，一部分用户线程可以继续执行，但仍然会有一小段时间的暂停，称为“停顿时间”（Pause Time）。停顿时间的长度取决于堆的大小和垃圾回收器的配置参数。

在G1垃圾回收器中，垃圾回收时会通过多线程的方式进行，会将整个堆划分为多个区域，每次只回收一部分区域，不会导致整个堆的暂停。但是，由于需要对整个堆进行划分和管理，G1垃圾回收器在处理大型堆时可能会带来一定的性能开销。

总之，**JVM垃圾回收时会导致程序暂停或阻塞**，不同的垃圾回收算法和具体实现会对应不同的停顿时间和性能开销。在进行应用程序开发时，需要根据实际需求和场景选择适合的垃圾回收器和配置参数，以实现更好的性能和稳定性。

### 垃圾收集器两个重要指标

在垃圾回收器中，两个重要的指标是：

1. **垃圾回收器的吞吐量**（Throughput）：指在一段时间内垃圾回收器所处理的垃圾量占总运行时间的比例。吞吐量越高，表示垃圾回收器的效率越高，可以在相同时间内处理更多的垃圾。
2. **垃圾回收器的停顿时间**（Pause Time）：指在执行垃圾回收操作时，应用程序需要暂停的时间。停顿时间越短，表示垃圾回收器对应用程序的影响越小，可以更好地保证应用程序的响应性和稳定性。

这两个指标是相互矛盾的，高吞吐量的垃圾回收器通常会产生较长的停顿时间，而低停顿时间的垃圾回收器通常会牺牲一定的吞吐量。

因此，在选择垃圾回收器时，需要根据实际应用场景和需求来平衡吞吐量和停顿时间。例如，对于需要高吞吐量的应用场景，可以选择使用并行垃圾回收器或CMS垃圾回收器；对于需要低停顿时间的应用场景，可以选择使用G1垃圾回收器或者ZGC垃圾回收器。

### Java的gc垃圾回收机制

Java的垃圾回收机制是由Java虚拟机（JVM）实现的，它采用了分代垃圾回收算法和可达性分析算法。

分代垃圾回收算法

Java的内存分为新生代和老年代两个部分，新生代又被分为Eden空间、Survivor 0空间和Survivor 1空间。新创建的对象会被分配到Eden空间中，当Eden空间满了之后，剩余的对象会被移动到Survivor 0空间或者Survivor 1空间中。当一个Survivor空间也满了之后，其中的存活对象会被移动到另一个Survivor空间中，同时年龄加1。当一个对象的年龄达到一定值时，它就会被移动到老年代中。

对于新生代的对象，Java采用了**复制算法进行垃圾回收**。即将存活的对象复制到另外一个空间中，并清空原来的空间。对于老年代的对象，Java采用了**标记-清除算法**、标记-整理算法或者分代算法进行回收。

可达性分析算法

Java的垃圾回收机制是基于对象的可达性分析算法实现的。当一个对象不再被任何引用变量所引用时，它就成为了垃圾。Java的垃圾回收器会定期扫描内存中的对象，找出不再被引用的对象，并将它们回收，释放其占用的内存空间。

Java还提供了finalize()方法，允许程序员在对象被垃圾回收之前执行一些清理工作。但是，由于finalize()方法会影响垃圾回收的性能和可靠性，因此在Java 9中已经被废弃。

需要注意的是，垃圾回收机制虽然可以自动管理内存，但也会对程序的性能产生一定的影响。因此，在编写Java程序时，需要合理地管理内存和避免频繁地创建和销毁对象，以尽量减少垃圾回收的影响。

### 请你介绍下 JVM 内存模型，分为哪些区域？各区域的作用是什么？

- 程序计数器（Program Counter Register） 程序计数器是JVM的一部分，它用于指示线程当前正在执行的指令地址。每个线程都有自己的程序计数器，并且线程的切换不会影响其他线程的程序计数器。程序计数器在执行Java方法、本地方法或者线程切换时都有用。
- Java虚拟机栈（Java Virtual Machine Stacks） Java虚拟机栈是用于存储Java方法执行时的栈帧（Stack Frame）的地方。每个Java方法都有一个对应的栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。Java虚拟机栈可以动态地扩展和收缩。
- 本地方法栈（Native Method Stack） 本地方法栈与Java虚拟机栈类似，不同的是，本地方法栈是为本地方法服务的。本地方法是使用JNI（Java Native Interface）实现的，它们的执行由本地方法栈来负责。本地方法栈和Java虚拟机栈类似，也可以动态地扩展和收缩。
- Java堆（Java Heap） Java堆是JVM内存管理中最大的一块，用于存储Java对象。Java堆是被所有线程共享的，因此它是线程安全的。Java堆可以动态地扩展和收缩。当Java堆被填满时，垃圾回收机制会自动回收无用的对象，以释放空间。
- 方法区（Method Area） 方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。方法区和Java堆一样，也是线程共享的。方法区也可以动态地扩展和收缩。
- 运行时常量池（Runtime Constant Pool） 运行时常量池用于存储编译期生成的各种字面量和符号引用，在运行时，可以通过符号引用来动态地解析和生成相应的对象或者方法。运行时常量池也是方法区的一部分。
- 直接内存（Direct Memory） 直接内存不是JVM中的一部分，但是它是Java NIO（New IO）包提供的一种高效的数据处理方式。直接内存是使用本地内存来直接进行I/O操作的内存空间，而不需要经过Java堆。

### JVM的架构，它底层的分布?

JVM（Java Virtual Machine）是 Java 程序的运行环境，它提供了一个独立于硬件和操作系统的虚拟计算机，使得 Java 程序可以在不同的平台上运行。JVM 的架构主要分为三层：**虚拟机、类库和应用程序接口（API）。**

JVM 底层的分布通常包括以下几个部分：

1. **类加载器**：**用于加载类文件到 JVM 中**，根据类的名称和路径在文件系统或网络中查找相应的二进制文件，并将其加载到运行时数据区。
2. **执行引擎**：用于执行加载到内存中的字节码指令，**将字节码指令翻译成机器码并运行。**
3. **内存管理器**：用于管理 JVM 的运行时数据区，包括堆、栈、方法区等。

**运行时数据区**分为以下五个部分：

1. 程序计数器：用于记录当前**线程**正在执行的**字节码指令的地址**。
2. Java 虚拟机栈：用于存储方法调用的**局部变量**、入参和返回值等信息。
3. 堆：**用于存储对象实例及其数组等数据**，是 JVM 运行时数据区中最大的一块。
4. 方法区：用于存储类的元数据、**常量池**、**静态变量**和编译后的代码等信息。
5. 本地方法栈：**用于执行本地方法的调用**，这些方法是使用 C 或 C++ 编写的。

JVM 的架构和运行时数据区的设计是为了提高 Java 程序的性能和安全性，同时也可以支持多线程、动态加载和垃圾回收等功能。

### Java的堆是怎么划分，为什么要这样分

Java的堆是由Java虚拟机管理的运行时数据区域之一，用于存储对象实例以及数组对象。Java的堆是在内存中分配的一块连续区域，该区域的大小可以在启动JVM时设定。

Java的堆可以分为两个部分：**新生代**和**老年代**。新生代又分为Eden空间、Survivor 0空间和Survivor 1空间。

新生代的对象通常很快就会被垃圾回收器回收掉，所以新生代的空间相对较小。新创建的对象会被分配到Eden空间中，当Eden空间满了之后，剩余的对象会被移动到Survivor 0空间或者Survivor 1空间中。当一个Survivor空间也满了之后，其中的存活对象会被移动到另一个Survivor空间中，同时年龄加1。**当一个对象的年龄达到一定值时，它就会被移动到老年代中。**

老年代用于存储存活时间较长的对象，因此老年代的空间相对较大。在老年代中，对象的存储和回收都比较耗时，所以老年代的垃圾回收算法和新生代的垃圾回收算法是不同的。

Java的堆采用这样的划分方式，可以有效地管理对象的内存分配和回收，并且可以提高垃圾回收的效率。同时，通过这种分代的方式，可以让新生代的对象尽快被回收，从而避免了内存空间的浪费。

## 三、Linux

### Linux 中的硬链接和软连接是什么，二者有什么区别？

在Linux中，硬链接（Hard Link）和软链接（Symbolic Link，也称为符号链接）都是用于创建文件链接的方法，但它们有一些区别：

1. 硬链接：硬链接是指在文件系统中创建一个新的文件名，该文件名指向已经存在的文件。硬链接与原始文件共享相同的inode和数据块，可以看作是原始文件的另一个名字，因此删除任何一个硬链接都不会影响文件本身或其他硬链接。硬链接不能跨越不同的文件系统。
2. 软链接：软链接是指在文件系统中创建一个新的文件，该文件包含了指向另一个文件的符号链接。软链接实际上是一个指向另一个文件或目录的快捷方式，软链接本身拥有自己的inode和数据块，因此删除软链接不会影响被链接的文件或目录。软链接可以跨越不同的文件系统。

二者的区别主要在于硬链接与原始文件共享inode，而软链接则是指向原始文件的路径名，因此删除原始文件会导致硬链接无法访问，而软链接仍然可以正常使用。同时，硬链接只能创建在同一个文件系统中，而软链接可以跨越不同的文件系统。由于硬链接共享相同的inode和数据块，因此硬链接不能用于目录。而软链接则可以用于链接目录，方便用户访问和管理文件。当字符串长度增长时，动态字符串会根据需要自动扩展缓冲区大小，从而避免了缓冲区溢出的问题。为了减少内存分配和释放的次数，Redis采用了空间惰性释放的策略，即在sds缩小时，并不立即释放多出来的空间，而是将其保留在free中，留待下次使用。另外，为了提高数据读取和比较效率，动态字符串内部也采用了预分配和惰性空间释放等优化技术。

### Linux常用指令

Linux 是一种开源操作系统，常用于服务器和嵌入式设备中。以下是 Linux 中常用的一些指令：

1. cd：切换当前目录。
2. ls：列出当前目录下的文件和目录。
3. mkdir：创建一个新目录。
4. rm：删除文件或目录。
5. cp：复制文件或目录。
6. mv：移动文件或目录，也可用于重命名文件或目录。
7. cat：显示文件内容。
8. grep：在文件中查找指定的字符串。
9. tail：显示文件的最后几行。
10. head：显示文件的前几行。
11. chmod：修改文件或目录的权限。
12. chown：修改文件或目录的所有者。
13. ps：列出当前正在运行的进程。
14. kill：结束一个进程。
15. top：实时显示系统中正在运行的进程信息。
16. ifconfig：查看和配置网络接口。
17. ping：测试网络连接状态。
18. netstat：显示网络连接状态。
19. ssh：远程登录到另一个 Linux 主机。
20. tar：打包和解压文件。
21. wget：从网络上下载文件。

## 四、redis

### redis常用数据结构

> 1. String(字符串)	SET key value				                       动态字符串
> 2. Hash (哈希)    HSET key field value                                哈希表
> 3. List(列表)         LPSUH key value                                    双向链表
> 4. Set(无序集合)      元素没有顺序且唯一   SADD key member
> 5. Sorted Set(有序集合)   ZADD key score member   可以根据score对元素进行排列

### Redis的数据过期策略

> 即redis的key过期后什么时候被删除？
>
> 1. 惰性删除：key过期后，不去管他，当访问的时候会检查其是否过期，过期就删除
>
>     优点：不占用cpu
>
>     缺点：占用内存
>
> 2. 定时删除：每隔一段时间，我们就对一些key进行检查，删除里面过期的key，有两种模式
>
>     slow模式：执行频率默认为10hz，每次不超过25ms，可以自定义执行频率
>
>     fast模式：执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms
>
>     优点：能够有效的释放内存
>
>     缺点：执行的频率和操作时长难以确定
>
> Redis的过期删除策略：惰性删除 + 定期删除两种策略进行配合使用

### redis的内存淘汰策略

> 数据的淘汰策略：当Redis中的内存不够用时，此时在向Redis中添加新的key，那么Redis就会按照某一种规则将内存中的数据删除掉，这种数据的删除规则被称之为内存的淘汰策略。
> Redis支持8种不同策略来选择要删除的key：
> 	noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。
> 	volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰
> 	allkeys-random：对全体key ，随机进行淘汰。
> 	volatile-random：对设置了TTL的key ，随机进行淘汰。
> 	allkeys-lru： 对全体key，基于LRU算法进行淘汰
> 	volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰
> 	allkeys-lfu： 对全体key，基于LFU算法进行淘汰
> 	volatile-lfu： 对设置了TTL的key，基于LFU算法进行淘汰
>
> 两个算法的重要概念，需记住
>
> **LRU**（Least Recently Used）最近最少使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。
>
> key1是在3s之前访问的, key2是在9s之前访问的，删除的就是key2
>
> **LFU**（Least Frequently Used）最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。
>
> key1最近5s访问了4次, key2最近5s访问了9次， 删除的就是key1
>
> LFU比较容易出现误判，建议优先使用LRU
>
> ![image-20230527170943587](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230527170943587.png)

### 缓存穿透

> 对一个数据库不存在的数据发起大量请求，造成数据库压力
>
> 解决方案：
>
> 1. 缓存空数据：在查询数据库不存在时，向redis写入一组空数据，并设置过期时间
>
>     - 优点：实现简单
>     - 缺点：在过期时间之内，可能造成短期的数据不一致
>
> 2. 布隆过滤器：在查询redis之前先查询布隆过滤器，不存在直接返回
>
>     ![image-20230526171509116](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230526171509116.png)
>
>     - 优点：占用内存小，没有额外的key存储
>     - 缺点：实现复杂存在误判的可能

### 缓存击穿

> 对于热点key过期了，此时有大量的请求访问数据库，造成压力
>
> 解决方案：
>
> 1. 互斥锁
>
>     当多个线程请求过来时，使用redis的互斥锁，只有一个线程能拿到锁，进行redis缓存重建，其余线程休眠一段时间后，重新访问
>
>     优点：能够保证数据的强一致性
>
>     缺点：其余线程需要等待，影响性能
>
> 2. 逻辑过期
>
>     添加一个逻辑过期字段，每次拿到redis数据判断是否过期，过期了就尝试获取锁，拿到锁开辟子线程进行缓存重建，主线程直接返回旧数据，其余线程没拿到锁也无需等待，直接返回旧数据
>
>     优点：线程无需等待，性能好
>
>     缺点：短期的数据不一致

### 缓存雪崩

> 指在一个时间段内，大量的key过期，请求直接打到数据库
>
> 解决方案：
>
> 在给key设置过期时间时在原有的过期时间上添加一个随机值

### Redis的持久化机制

> 持久化即将内存中的数据写入磁盘
>
> 1. RDB持久化：Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。
>
>     两种命令：
>
>     save：由redis主进程来执行，会阻塞其他请求
>
>     bgsave：开辟子进程来执行备份，可以在redis配置文件配置保存策略
>
>     ![image-20230527161816195](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230527161816195.png)
>
> 2. AOF持久化（默认是关闭的）：Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。
>
>     有三种刷盘策略
>
>     ![image-20230527162038375](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230527162038375.png)
>
>     AOF文件会有许多无效的操作，所以文件比RDB大很多，可以通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。
>
> 两者对比
>
> ![image-20230527162248970](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230527162248970.png)

### Redis的分布式锁

> 为什么要有分布式锁？由于本地锁是基于JVM的，集群模式下无法生效
>
> 应用场景：集群模式下的抢单，定时任务，接口的幂等性
>
> redis分布式锁存在的问题：不可重入，锁的过期时间难以确定没有续期机制，没有重试机制
>
> 基于redis封装的框架redisson分布式锁（基于setnx+lua脚本）
>
> ![image-20230527173552314](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230527173552314.png)
>
> 1. 续期机制：看门狗机制
>
> 2. 可重入：加锁的同时会记录线程id表示，同一个线程可以获取同一把锁
>
>     ![image-20230527173811623](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230527173811623.png)
>
> ![image-20230527173940304](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230527173940304.png)

### Redis是单线程的，为什么这么快？

> 1. Redis是**纯内存操作**，并且采用了高效的数据结构，执行速度非常快
> 2. Redis 采用单线程模型可以**避免了多线程之间的竞争**，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。
> 3. 使用I/O多路复用模型，非阻塞IO
>
> Redis是纯内存操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度， I/O多路复用模型主要就是实现了高效的网络请求
>
> 单线程是指利用单个线程来同时监听多个Socket（客户端） ，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。目前的I/O多路复用都是采用的epoll模式实现，它会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间，不需要挨个遍历Socket来判断是否就绪，提升了性能。
>
> **Redis 单线程指的是「接收客户端请求->解析请求 ->进行数据读写等操作->发送数据给客户端」这个过程是由一个线程（主线程）来完成的**，这也是我们常说 Redis 是单线程的原因。Redis 为「关闭文件、AOF 刷盘、释放内存」这些任务创建单独的线程来处理，是因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。
>
> Redis网络模型：
>
> ![image-20230713121408980](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230713121408980.png)

### redis数据和Mysql的一致性如何保证

> redis和mysql的数据不一致主要是由于操作数据库和操作redis不是一个原子性操作
>
> - 先删除缓存在更新数据库出现的问题
>
>     线程一删除缓存	线程二读取不到缓存查询数据库并写入缓存	线程一更新数据库
>
>     可以发现此时缓存中写入的仍然是旧数据
>
> - 先更新数据库在删除缓存可能的问题
>
>     缓存过期	线程二查询数据库	线程一更新数据库并删除缓存	线程二将查询的数据写入缓存
>
>     可以发现缓存中的数据是线程二查询的数据，仍然是旧数据
>
> 解决方案：
>
> 1. 延时双删：
>
>     先删除缓存	在更新数据库	结合业务过一段时间在删除缓存
>
>     缺点：还是会存在脏数据，"一段时间"难以确定
>
> 2. 加锁：要求数据的强一致性
>
>     由于使用缓存的数据一般都是读多写少，所以可以考虑使用共享锁，排它锁，redisson有自带的读写锁
>
>     读+读:   无需等待
>
>     读+写：读完才能写
>
>     写+写：前一写锁释放才能继续获取写锁
>
>     写+读：写完才能读
>
>     在进行读数据的时候使用redisson读锁：在有读取请求的时候，更新数据库的请求必须等待
>
>     在更新数据库的时候使redisson写锁：在有更新数据库的请求时，读取请求必须等待
>
>     优点：能够保存数据的强一致性
>
>     缺点：影响性能
>
> 3. 异步通知：保证最终的一致性
>
>     ![image-20230527154942255](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230527154942255.png)
>
>     ![image-20230527155021706](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230527155021706.png)

### redis主从同步（读写分离）

> 单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。
>
> 主从同步原理：(也是保存数据一致性的关键)
>
> ![image-20230527202610017](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230527202610017.png)
>
> 全量同步（发生在第一次同步）：
> 1.从节点请求主节点同步数据（携带上 replication id、 offset ）
> 2.如果从节点replication id和主节点不同（之后会同步主从配置信息）或者 offset为0 则是第一次进行同步
> 3.主节点执行bgsave，生成rdb文件后，发送给从节点去执行
> 4.在rdb生成执行期间，主节点会以命令的方式记录到缓冲区（一个日志文件）
> 5.把生成之后的命令日志文件发送给从节点进行同步（增量同步）
>
> 增量同步（之后的同步）：
> 1.从节点请求主节点同步数据，主节点判断不是第一次请求，不是第一次就获取从节点的offset值
> 2.主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步
>
> 注意事项：redis主从模式并不能保持数据的强一致性，但可以保证最终一致性

### redis哨兵

> 为了保证redis的高并发高可用，采用哨兵对redis进行检测
>
> ![image-20230527204741788](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230527204741788.png)
>
> ![image-20230527204807538](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230527204807538.png)
>
> ![image-20230527204849600](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230527204849600.png)
>
> 集群脑裂是由于主节点和从节点和sentinel处于不同的网络分区，使得sentinel没有能够心跳感知到主节点，所以通过选举的方式提升了一个从节点为主，这样就存在了两个master，就像大脑分裂了一样，这样会导致客户端还在老的主节点那里写入数据，新节点无法同步数据，当网络恢复后，sentinel会将老的主节点降为从节点，这时再从新master同步数据，就会导致数据丢失
> 解决：我们可以修改redis的配置，可以设置最少的从节点数量以及缩短主从数据同步的延迟时间，达不到要求就拒绝请求，就可以避免大量的数据丢失
>
> redis中有两个配置参数：
> min-replicas-to-write 1   表示最少的salve节点为1个
> min-replicas-max-lag 5  表示数据复制和同步的延迟不能超过5秒

### Redis分片集群

> ![image-20230527223845940](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230527223845940.png)
>
> ![image-20230527223940958](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230527223940958.png)
>
> 

### redis的事务机制

> 1. **事务开始** ：使用`MULTI`命令开始一个事务。之后的所有命令都将被记录在事务队列中，而不会立即执行。
> 2. 命令入队 ：在事务开始后，通过依次执行一系列的Redis命令，这些命令将按顺序进入事务队列，但不会立即执行。
> 3. 队列检查：在队列检查阶段，Redis会检查事务队列中的命令是否存在语法错误或逻辑错误。
> 4. **事务执行**：使用`EXEC`命令执行事务中的所有命令。此时，Redis会按照命令在事务队列中的顺序依次执行这些命令。
> 5. 原子性执行：在事务执行期间，如果发生了错误或异常，Redis会将事务标记为失败，如果所有命令都成功执行，Redis会将事务标记为成功。
> 6. 结果返回：事务执行完成后，Redis会将每个命令的执行结果返回给客户端。如果事务执行失败，则返回的结果将反映执行失败的状态。
> 7. 取消事务：可以使用`DISCARD`取消事务，这将导致事务被中止，并清空事务队列。
>
> 注意事项：事务执行期间如果有一个命令失败了，并不会影响会面的任务执行，前面执行成功的命令也不会回滚

## 五、MySql

### MySQL的字段类型

> ![MySQL 常见字段类型总结](https://raw.githubusercontent.com/njauwj/java-note/master/summary-of-mysql-field-types.png)

### 在MySQL中如何定位慢查询

> 出现场景：
>
> 聚合查询
> 多表查询
> 表数据量过大查询
> 深度分页查询
> 表象：页面加载过慢、接口压测响应时间过长（超过1s）
>
> 定位方法：
>
> 1. 开源工具：可以查看到接口响应时间和数据库响应时间
>
>     调试工具：Arthas 
>     运维工具：Prometheus 、Skywalking
>
> 2. 开启mysql慢查询日志(一般仅在测试环境下开启)
>
>     慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志
>     如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：
>
>     ```
>     # 开启MySQL慢日志查询开关
>     slow_query_log=1
>     # 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
>     long_query_time=2
>     ```
>
>     ![image-20230528220018325](https://raw.githubusercontent.com/njauwj/java-note/master/image-20230528220018325.png)

### SQL执行很慢如何分析

> ![image-20230528222806265](https://raw.githubusercontent.com/njauwj/java-note/master/202308072231550.png)
>
> ![image-20230528222832248](https://raw.githubusercontent.com/njauwj/java-note/master/202308072231720.png)
>
> ![image-20230528222910930](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230528222910930.png)
>
> ![image-20230528223231734](https://raw.githubusercontent.com/njauwj/java-note/master/202308072231667.png)

### MySQL索引

> 索引是一种`数据结构`，用来提高数据表的检索效率。
>
> 优点：加快数据的查找速度
>
> 缺点：占用储存空间，降低了增删改的效率

### 聚簇索引与非聚簇索引以及回表查询

> `聚簇索引`（聚集索引）：**数据与索引放到一块**，B+树的叶子节点保存了整行数据，**有且只有一个**,默认是主键
> `非聚簇索引`（二级索引）：**数据与索引分开存储**，B+树的叶子节点只保存了索引列和对应的主键，可以有多个
>
> 通过二级索引找到对应的主键值，到聚集索引中查找整行数据，这个过程就是`回表`
>
> ![image-20230529104742734](https://raw.githubusercontent.com/njauwj/java-note/master/202308072231707.png)
>
> ![image-20230529104813631](https://raw.githubusercontent.com/njauwj/java-note/master/202308072231066.png)
>
> ![image-20230529104825964](https://raw.githubusercontent.com/njauwj/java-note/master/202308072232200.png)
>

### 覆盖索引

> **不需要回表查询**
>
> ![image-20230529122955187](https://raw.githubusercontent.com/njauwj/java-note/master/202308072232098.png)

### MySQL超大分页处理

> 采用`覆盖索引`加`子查询`
>
> ![image-20230529123257158](https://raw.githubusercontent.com/njauwj/java-note/master/202308072232177.png)
>
> ![image-20230529123350253](https://raw.githubusercontent.com/njauwj/java-note/master/202308072232825.png)
>
> 

### 什么时候使用索引

> 使用的情况：
>
> - 频繁用于条件查询的字段
> - 用作于排序和分组的字段
> - 表连接时，对连接条件字段添加索引，可以提高连接效率
>
> 不使用情况：
>
> - 表数据量很小时，不要建立索引
> - 经常进行增删改的列不要建立索引
> - 区分度不高的列也不建议建立索引，比如性别

### VARCHAR和CHAR的区别

> vachar：字符串长度是可变的，用多少占多少
>
> char：字符串长度是不可变的，定义多少占多少，不足的部分用空格填充

### MySQL索引的数据结构

> **MySQL的InnoDB存储引擎使用的是`B+树`索引。**
> 
> 非叶子节点只储存索引列和指针
>
> 叶子结点存储真正的数据并维护了一个双向链表
> 
> 下面的图为聚集索引的B+树示例图
> 
>![img](https://raw.githubusercontent.com/njauwj/java-note/master/202308081136649.jpeg)

### 为什么B+树比B树更适合实现数据库索引？

> - B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。减少更多的I/O支出。
> -  B+树的叶子节点形成了一个有序链表，适合范围查询。而B树的叶子节点不一定有序，难以高效地支持范围查询。

### MySQL常见索引

> 1. `主键索引`（Primary Key Index），创建表时会在主键上自动加上。
>
>     ```sql
>     CREATE TABLE employees (
>         employee_id INT PRIMARY KEY,
>     );
>     ```
>
> 2. 唯一索引（Unique Index），保证数据的唯一性
>
>     ```sql
>     CREATE TABLE users (
>         username VARCHAR(50) UNIQUE,
>     );
>     ```
>
> 3. 普通索引（Index），最常见的索引，用于**加速查询**
>
>     ```sql
>     CREATE TABLE products (
>         category_id INT,
>         INDEX idx_product_category (category_id)
>     );
>     ```
>
> 4. 全文索引（Full-Text Index）全文索引用于全文搜索，对文本内容进行高效的**模糊匹配**。
>
>     ```sql
>     CREATE TABLE articles (
>         title VARCHAR(200),
>         content TEXT,
>         FULLTEXT (title, content)
>     );
>     ```
>
> 5. 组合索引（Composite Index）组合索引是基于多列的索引，用于加速多个列的联合查询。
>
>     ```sql
>     CREATE TABLE orders (
>         order_id INT PRIMARY KEY,
>         customer_id INT,
>         order_date DATE,
>         ...
>         INDEX idx_customer_order_date (customer_id, order_date)
>     );
>     ```

### MySQL索引失效情况

> 1. 使用联合索引时，违反了`最左原则`：如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。
>
>     联合索引 index(a,b,c)相当于创建了索引 index(a),index(a,b),index(a,b,c)
>
>     ![image-20230529221700258](https://raw.githubusercontent.com/njauwj/java-note/master/202308072232554.png)
>
> 2. 范围查询右边的列索引会失效
>
>     ![image-20230529221806067](https://raw.githubusercontent.com/njauwj/java-note/master/202308072232990.png)
>
> 3. 不能对索引列进行运算操作，包括函数运算
>
> 4. 索引列进行了类型转换也会索引失效
>
>     ![image-20230529221941220](https://raw.githubusercontent.com/njauwj/java-note/master/202308072232677.png)
>
> 5. 使用了左模糊查询
>
>     %abc% 失效			abc%  不会失效
>
> 6. 使用 or 连接查询条件时，两边的字段有一个不是索引列，索引就会失效

### 如何优化SQL

> 1. 表的设计优化(可以参考阿里开发手册)
> 2. 索引优化
> 3. SQL语句优化
> 4. 主从复制、读写分离
> 5. 分库分表

### 事务的四大特性（ACID）是什么？

> 事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。
>
> `原子性`（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。
> `一致性`（Consistency）：事务完成时，必须使所有的数据都保持一致状态。(比如转账，A扣了100，B必须增加了100，数据要一致)
> `隔离性`（Isolation）：事务之间是隔离的，不会相互影响
> `持久性`（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。

### 事务的隔离级别

> 存在的问题：
>
> - **`脏读`**是指在一个事务处理过程里读取了另一个未提交的事务中的数据。
> - **`不可重复读`**是指在对于数据库中的某行记录，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，另一个事务修改了数据并提交了。
> - **`幻读`**是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行，就像产生幻觉一样，这就是发生了幻读。
>
> 幻读和不可重复读都是读取了另一条已经提交的事务，不同的是不可重复读的重点是修改，幻读的重点在于新增或者删除。
>
> 事务隔离级别
>
> 1. **`读未提交`（Read Uncommitted）**：最低级别，事务未提交的数据对其他事务也可见。可能导致**脏读、不可重复读和幻读**问题。
> 2. **`读已提交`（Read Committed）**：事务提交后的数据才对其他事务可见，解决了脏读问题，但仍可能出现**不可重复读和幻读问题。**
> 3. **`可重复读`（Repeatable Read）**：在一个事务中多次读取同一数据，都会返回相同的结果。解决了脏读和不可重复读问题，但仍可能出现**幻读问题。**
> 4. **`序列化`（Serializable）**：最高级别，事务按照**串行方式**执行，确保了最高的数据一致性，但并发性能最差。

### redo log 和 undo log的区别

> ![image-20230530233942483](https://raw.githubusercontent.com/njauwj/java-note/master/202308072232133.png)
>
> ![image-20230530233951480](https://raw.githubusercontent.com/njauwj/java-note/master/202308072232915.png)
>
> ![image-20230530234026889](https://raw.githubusercontent.com/njauwj/java-note/master/202308072232985.png)

### 什么是MVCC

> ![image-20230601122032601](https://raw.githubusercontent.com/njauwj/java-note/master/202308072233427.png)
>
> 

### MySQL主从同步原理

> ![image-20230601230142234](https://raw.githubusercontent.com/njauwj/java-note/master/202308072233136.png)
>
> 1. 主库在提交事务后，会将数据变更记录在二进制binlog日志中
> 2. 从库读取主库的binlog日志，写入自己的中继日志relaylog中
> 3. 从库执行relaylog日志的事件，保存到自己的数据库

### MySQL分库分表

> ![image-20230601232233699](https://raw.githubusercontent.com/njauwj/java-note/master/202308072233923.png)
>
> ![image-20230601232247990](https://raw.githubusercontent.com/njauwj/java-note/master/202308072233594.png)
>
> ![image-20230601232303343](https://raw.githubusercontent.com/njauwj/java-note/master/202308072233314.png)
>
> ![image-20230601232338241](https://raw.githubusercontent.com/njauwj/java-note/master/202308072233839.png)
>
> ![image-20230601232353641](https://raw.githubusercontent.com/njauwj/java-note/master/202308072233357.png)
>
> ![image-20230601232435185](https://raw.githubusercontent.com/njauwj/java-note/master/202308072233624.png)

### MySQL锁

> https://xiaolincoding.com/mysql/lock/mysql_lock.html#%E5%85%A8%E5%B1%80%E9%94%81
>
> ![img](https://raw.githubusercontent.com/njauwj/java-note/master/202308072233866.png)

### MySQL乐观锁

> https://bbs.huaweicloud.com/blogs/300169
>
> update test_account set account = account - 100, version = version + 1  where id = 1 and version = 1
>
> 核心：执行update语句时，会自动在该行加上排它锁
>
> 但有多个事务执行上面的方法时，只有一个事务能获取到排它锁，其他事务必须等待，但此时version的值已经变了，其他事务会执行失败，version的值可以选取特殊字段，例如库存
>
> update goods set store  = store - 1 where id = 11 and store > 0
>
> 注意：当我们在执行update语句时，后面的where条件一定要包含索引列，否则可能全表锁住

### MySQL存储引擎

> `show engines`查看MySQL支持的存储引擎
>
> ![image-20230807223815806](https://raw.githubusercontent.com/njauwj/java-note/master/202308072238698.png)
>
> 1. `InnoDB`：默认的存储引擎，支持事务，行级锁，外键约束，数据与索引放在一块
> 2. `MYISAM`：不支持事务，行级锁，外键约束，只支持表锁，数据与索引分离，**适合读多写少**，MySQL 5.5 之前是作为默认存储引擎的，但是由于只支持表锁，在并发写的时候效率很低
> 3. `MEMORY`：不支持事务，将表数据保存至内存中，适合缓存和临时数据存储
>
> ![image-20230807224824895](https://raw.githubusercontent.com/njauwj/java-note/master/202308072248934.png)

## 六、Java基础

### Java的特点

> 简单易学：去掉了显式指针，自带垃圾回收机制，不需要手动释放内存。
>
> 面向对象：支持封装、继承、多态等面向对象的特性。
>
> 跨平台：一次编译到处运行，通过Java虚拟机（JVM）实现了跨平台性，可以在不同的操作系统上运行相同的Java程序。

### JVM vs JDK vs JRE

> `JVM`
>
> Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。
>
> 注：别的语言也可以编译成Java字节码在JVM里运行
>
> ![运行在 Java 虚拟机之上的编程语言](https://raw.githubusercontent.com/njauwj/java-note/master/202308072234582.png)
>
> #### `JDK` 和 `JRE`
>
> JDK（Java Development Kit），它是功能齐全的 Java SDK，是提供给开发者使用的，能够创建和编译 Java 程序。他包含了 JRE，同时还包含了编译 java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。
>
> JRE（Java Runtime Environment） 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。
>
> 也就是说，JRE 是 Java 运行时环境，仅包含 Java 应用程序的运行时环境和必要的类库。而 JDK 则包含了 JRE，同时还包括了 javac、javadoc、jdb、jconsole、javap 等工具，可以用于 Java 应用程序的开发和调试。如果需要进行 Java 编程工作，比如编写和编译 Java 程序、使用 Java API 文档等，就需要安装 JDK。
>
> ![JDK 包含 JRE](https://raw.githubusercontent.com/njauwj/java-note/master/202308072234910.png)

### .class字节码

> JVM可以理解的代码就是字节码
>
> ![Java程序转变为机器代码的过程](https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code.png)
>
> 格外注意的是 `.class->机器码` 这一步，在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 `JIT`（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 **Java 是编译与解释共存的语言**
>
> ![Java程序转变为机器代码的过程](https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code-with-jit.png)
>
> ![JDK、JRE、JVM、JIT 这四者的关系](https://oss.javaguide.cn/github/javaguide/java/basis/jdk-jre-jvm-jit.png)

### Java的八种基本数据类型

> ![image-20230730232408120](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230730232408120.png)

### 抽象类和接口的区别

> 共同点：
>
> - 都不能被实例化
> - 都可以定义抽象方法
>
> 不同点：
>
> - 抽象类可以有构造器，接口没有
> - 接口里的方法默认都是（public abstract）抽象方法，而抽象类可以有普通方法（接口也可以使用default关键字定义有方法体的函数）
> - 接口里的变量都是常量（public static final）

### 重写和重载的区别

> ![image-20230731161911825](https://typora-1314902743.cos.ap-nanjing.myqcloud.com//interview/image-20230731161911825.png)
>
> 任何方法都可以被重载，但如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法

### 基本类型和包装类型的区别

> **用途**：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。
>
> **存储方式**：基本数据类型的`局部变量`存放在 Java 虚拟机`栈`中的`局部变量表`中，基本数据类型的`成员变量`（未被 `static` 修饰 ）存放在 Java 虚拟机的`堆`中。包装类型属于`对象类型`，我们知道几乎所有对象实例都存在于`堆`中。
>
> **占用空间**：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。
>
> **默认值**：成员变量包装类型不赋值就是 `null` ，而基本类型有默认值且不是 `null`。
>
> **比较方式**：对于基本数据类型来说，`==` 比较的是值。对于包装数据类型来说，`==` 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 `equals()` 方法。

### 包装类型的缓存机制

> `Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。
>
> 在缓存之间的数据，会直接去缓存里取不会创建新对象，所以对象的比较最好用equals，不要用==
>
> 例如：Integer a；Integer b；a == b 在 **[-128，127]** 才是成立的，以外的数据会返回false

### 自动拆箱装箱

> - **装箱**：将基本类型用它们对应的引用类型包装起来；Integer i = 10 相当于 Integer i = Integer.valueOf(10)   //装箱
> - **拆箱**：将包装类型转换为基本数据类型；int n = i 相当于 int n = i.intValue()   //拆箱

### 成员变量和局部变量的区别

> - 成员变量可以有访问修饰符，局部变量没有
> - 成员变量有默认值，而局部变量必须初始化
> - 成员变量随着对象创建而创建，销毁而销毁，局部变量在方法执行时创建，方法结束后销毁
> - 成员变量可以被类中的所有方法访问，局部变量只能在当前方法被访问
> - 成员变量存放在堆中，局部变量存放在栈中

### 静态方法为什么不能调用非静态成员?

> 静态方法是属于类的，在**类加载**的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在**对象实例化**之后才存在，需要通过类的实例对象去访问。
>
> 在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。

### （对象拷贝）深拷贝和浅拷贝的区别，引用拷贝

> 实现`Cloneable`接口重写Object里的`clone`方法
>
> 对象拷贝：
>
> 浅拷贝：如果对象里面有引用对象的话只会拷贝其地址，所以对引用对象的修改也会影响原对象
>
> 深拷贝：则会创建一个新的引用对象，保存其地址，对其的修改也不会影响到原对象
>
> 引用拷贝：
>
> 两个不同的引用指向同一个对象，不会创建对象，例如 Person p1 = new Person(); Person p2 = p1;
>
> ![image-20230731175939412](https://typora-1314902743.cos.ap-nanjing.myqcloud.com//interview/image-20230731175939412.png)
>
> ![image-20230731180055923](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230731180055923.png)

### 字符串常量池

>  **String s1 = new String("abc");这句话创建了几个字符串对象？**
>
>  如果字符串常量池中不存在字符串对象“abc”的引用，那么它将首先在字符串常量池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。
>
>  **String s1 = “abc”**
>
>  如果字符串常量池存在“abc”引用，则直接返回该引用，负责在常量池创建对象“abc”，并返回其引用
>
>  **String s1 = new String("abc").intern()**
>
>  和String s1 = “abc”本质一样
>
>  

### 线程的创建方式

>1. 实现Thread类，重写run方法，调用start()方法
>
>    ```java
>    MyThread thread = new MyThread();
>    thread.strat();
>    ```
>
>2. 实现Runable接口，重写run方法,调用start()方法
>
>    ```java
>    MyRunnable runnable = new MyRunnable();
>    Thread thread = new Thread(runnable);
>    thread.start();
>    ```
>
>3. 使用匿名内部类
>
>    ```java
>    Thread thread = new Thread(new Runnable() {
>        public void run() {
>            // 线程的执行逻辑
>        }
>    });
>    thread.start();
>    ```

### 面向对象的三大特性

> 封装：隐藏对象的属性以及方法代码的具体实现，只对外暴露方法的接口
>
> 继承：对象具有共同的一些特性，子类可以直接继承这些属性，不需要重新定义
>
> 多态：
>
> - 编译时多态（方法的重载）方法名相同却有着不同的行为
> - 运行时多态 （方法的重写）父类引用指向子类对象，编译类型是父类，而运行类型是子类，运行时真正执行的是子类的方法

### 什么是线程？线程和进程有什么区别？

线程是**程序执行的最小单位**，它是进程的一部分，是进程内的一个独立执行单元。每个线程都有自己的栈空间、程序计数器和局部变量等线程私有的资源，但是它们共享进程的内存空间和其他资源，如打开的文件、网络连接等。线程可以并发执行，可以提高程序的效率和响应速度。

进程是操作系统中执行的一个程序实例，它包含了程序代码、数据、堆栈等资源，是操作系统进行资源分配和调度的基本单位。每个进程都有自己独立的地址空间和资源，进程之间是相互独立的，不能直接访问其他进程的资源。进程可以并发执行，但是进程间的切换和通信的开销比线程大。

线程和进程的主要区别在于：

1. 线程是进程的一部分，是进程内的独立执行单元，进程是操作系统中执行的一个程序实例。
2. 线程共享进程的内存空间和其他资源，如打开的文件、网络连接等，进程之间是相互独立的。
3. 线程比进程更轻量级，创建和销毁的开销更小，切换和通信的开销也比进程小。
4. 线程之间的同步和通信更容易，因为它们共享相同的内存空间和资源。

总之，线程和进程都是多任务并发执行的基本单位，但是它们的性质和特点是不同的，需要根据具体的应用场景来选择使用哪种方式。

### 获取Class对象的方式

> 1. Class.*forName*(类的路径)
> 2. 类.*class*()
> 3. 对象.*getClass*()
> 4. ClassLoader.*getSystemClassLoader*().*loadClass*(类的路径)

### ClassLoader作用

在Java中，ClassLoader（类加载器）是负责**将Java类加载到Java虚拟机（JVM）**中的组件。ClassLoader的主要作用包括：

1. 加载类：ClassLoader根据类的名称查找类的字节码文件，并将其加载到JVM中。ClassLoader可以从不同的来源加载类，例如本地文件系统、网络等。
2. 安全隔离：ClassLoader将不同的类加载到不同的命名空间中，以避免不同类之间的冲突。这种隔离还可以帮助保护系统的安全性。
3. 动态加载：ClassLoader允许在程序运行时动态加载类，这对于一些需要动态扩展的应用程序非常有用。
4. 缓存类：ClassLoader在内存中缓存已经加载的类，以提高加载速度和系统性能。

总之，ClassLoader是Java虚拟机的重要组件之一，它负责将Java类加载到内存中，并提供安全隔离、动态加载和缓存等功能，使得Java应用程序能够高效地运行。

### hashMap的底层原理

HashMap是Java中最常用的数据结构之一，它是一种基于哈希表实现的键值对存储结构，使用哈希函数将键映射到表中的位置，从而实现快速的查找和插入操作。

HashMap的底层数据结构是一个数组和一个链表或红黑树（JDK 1.8及以上版本），数组中的每个元素都是一个链表或红黑树的头节点，链表或红黑树中保存着具有相同哈希值的键值对。当需要查找或插入一个键值对时，HashMap首先根据键的哈希值计算出在数组中的位置，然后遍历对应位置的链表或红黑树，找到对应的键值对。

HashMap的put方法用于向Map中添加键值对，当添加的键已经存在时，会将对应的值替换为新的值。put方法的实现过程如下：

1. 计算键的哈希值，并计算在数组中的位置。
2. 如果该位置为空，则创建一个新的链表或红黑树，将键值对插入到链表或红黑树中。
3. 如果该位置不为空，则遍历链表或红黑树，查找是否已经存在相同的键。
4. 如果找到相同的键，则替换对应的值。
5. 如果没有找到相同的键，则将新的键值对插入到链表或红黑树中。

HashMap的get方法用于获取指定键的值，get方法的实现过程如下：

1. 计算键的哈希值，并计算在数组中的位置。
2. 遍历对应位置的链表或红黑树，查找是否存在相同的键。
3. 如果找到相同的键，则返回对应的值。
4. 如果没有找到相同的键，则返回null。

需要注意的是，HashMap在进行哈希运算时可能会发生哈希冲突，即不同的键可能会映射到同一个位置，这时需要使用链表或红黑树来解决冲突。为了保证HashMap的性能，需要尽量避免哈希冲突的发生，可以使用合适的哈希函数、调整数组的大小等方法来减少哈希冲突的概率。

### HashMap的哈希算法是？

HashMap 的哈希算法主要分为两个步骤：第一步是对键对象进行哈希计算，第二步是对哈希值进行处理，以得到在哈希表中的索引位置。

1. 对键对象进行哈希计算

HashMap 对键对象的哈希计算过程如下：

(1) 假设键对象的类型为 K，首先调用 K 的 hashCode() 方法计算哈希值 h1。

(2) 然后将 h1 的**高位和低位进行异或运算**，得到新的哈希值 h2 = h1 ^ (h1 >>> 16)。这一步主要是为了使得高位的信息也能够参与到哈希值的计算中，从而降低哈希冲突的概率。

2. 对哈希值进行处理

接下来，HashMap 对哈希值进行处理，以得到在哈希表中的索引位置。具体来说，**HashMap 将哈希值 h2 和哈希表的容量 capacity 取余**，得到在哈希表中的索引位置 index = h2 % capacity。

需要注意的是，由于哈希值的范围可能比哈希表的容量要大得多，因此，在计算索引位置时还需要对哈希值进行一些处理，以保证索引位置在有效范围内。具体来说，当哈希表的容量为 2 的幂次方时，可以使用位运算代替取余运算，从而提高计算效率。具体实现方式是：index = (n - 1) & h2，其中 n 表示哈希表的容量，& 表示按位与运算。

总体来说，HashMap 的哈希算法主要依赖于键对象的哈希值和哈希表的容量，通过将哈希值和容量取余或者进行位运算，得到在哈希表中的索引位置。哈希算法的设计可以使得键对象的哈希分布更加均匀，从而提高哈希表的性能和效率。

### 为什么要有hashCode

> 当你把对象加入 `HashSet` 时，`HashSet` 会先计算对象的 `hashCode` 值来判断对象加入的位置，同时也会与其他已经加入的对象的 `hashCode` 值作比较，如果没有相符的 `hashCode`，`HashSet` 会假设对象没有重复出现。但是如果发现有相同 `hashCode` 值的对象，这时会调用 `equals()` 方法来检查 `hashCode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 `equals` 的次数，相应就大大提高了执行速度。也就是说 `hashCode` 帮助我们大大缩小了查找成本。
>
> 那为什么还要提供equals？
>
> 因为 `hashCode()` 所使用的哈希算法也许刚好会让不同对象传回相同的哈希值，也就是哈希碰撞

### 为什么重写equals还要重写hashcode方法

> 因为在集合中只有当hashcode相等equals也相等我们才认为两个对象是相同的，如果不写hashcode，就会出现equals判断相等，但hashcode不相等，拿hashset举例，hashcode的值是来确定索引的，两个equals相同的对象却由于hashcode不同而都存放到了set集合中，这与我们预期是不一致的

### ==和equals的区别

> 1. 如果没有重写equals两者完全相同
> 2. 引用类型== 比较的是两个对象的地址是否相同，基本数据类型比较的是值是否相等
> 3. equals 一般都会被重写，用来比较两个对象的属性是否相等

### final关键字的作用

> - final类不能被继承
> - final方法不能被重写
> - final修饰的基本数据类型是常量值不能改变
> - final修饰的引用类型指向地址不能改变，但可以改变对象的属性，例如数组里的某个元素值，对象的某个属性值

### String为什么是不可变的

> String 底层使用 private final char value[];
>
> - private 保证value对外不可见
> - final保证value的指向地址不可变
> - String里没有方法能对value数组的元素进行写的操作，这点很重要，因为就算被final修饰，数组里的元素值仍然是可变的

### String字符串的拼接

> Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个`重载过的运算符`。
>
> 字符串对象通过“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 。

### Java的常用集合类

> Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 `Collection`接口，主要用于存放单一元素；另一个是 `Map` 接口，主要用于存放键值对。对于`Collection` 接口，下面又有三个主要的子接口：`List`、`Set` 和 `Queue`。
>
> ![Java 集合框架概览](https://raw.githubusercontent.com/njauwj/java-note/master/java-collection-hierarchy.png)

### Java集合类的数据结构

> **List**:
>
> - `ArrayList`：`Object[]` 数组
> - `Vector`：`Object[]` 数组
> - `LinkedList`：双向链表
>
> **Set**:
>
> `HashSet`(无序，唯一): 基于 `HashMap` 实现的，底层采用 `HashMap` 来保存元素
>
> `LinkedHashSet`: `LinkedHashSet` 是 `HashSet` 的子类，并且其内部是通过 `LinkedHashMap` 来实现的。有点类似于我们之前说的 `LinkedHashMap` 其内部是基于 `HashMap` 实现一样，不过还是有一点点区别的
>
> `TreeSet`(有序，唯一): 红黑树(自平衡的排序二叉树)
>
> **Map**:
>
> `HashMap`：JDK1.8 之前 `HashMap` 由`数组+链表`组成的，数组是 `HashMap` 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 `8`）（将链表转换成红黑树前会判断，如果当前数组的长度小于 `64`，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间
>
> `LinkedHashMap`：`LinkedHashMap` 继承自 `HashMap`，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，`LinkedHashMap` 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。
>
> `Hashtable`：数组+链表组成的，数组是 `Hashtable` 的主体，链表则是主要为了解决哈希冲突而存在的
>
> `TreeMap`：红黑树（自平衡的排序二叉树）

### HashMap和HashTable的区别

> 1. HashTable是线程安全的，内部的方法都有`synchronized`修饰
> 2. Hashtable不允许 key 或者 value 为 `null` 值
> 3. HashTable并没有红黑树化的机制
> 4. HashMap 默认初始化容量为`16`，扩容为`2n`，HashTable 初始化为`11`，扩容为`2n+1`

### ConcurrentHashMap

> HashTable是对整个方法加synchronized，这样子效率非常低，因为正常情况插入的值都是不同的，多个线程之间并不会影响
>
> ConcurrentHashMap 对 Node 加锁，当插入的数组索引为空时直接插入无需获取锁，当插入的位置有值时需要获取synchronized锁 ，这也是一种乐观锁的思想 Node + CAS + synchronized
>
> ![Java8 ConcurrentHashMap 存储结构](https://raw.githubusercontent.com/njauwj/java-note/master/java8_concurrenthashmap.png)

### StringBuffer和StringBuilder的区别

> 1. 两者均为AbstractStringBuilder的子类，方法和功能是差不多的
> 2. StringBuffer所有的方法都加上了synchronized，是线程安全的，但是会影响性能
> 3. 内部使用可变长度的字符数组（char[]）来存储字符串，初始化数组大小为16

### 访问修饰符 public、private、protected，以及无修饰符（默认）时的区别

Java中，访问修饰符用于控制类、接口、变量、方法等的访问范围和可见性，常见的访问修饰符包括public、private、protected和默认（无修饰符）。

1. public：被public修饰的类、接口、变量、方法可以被任何其他类、接口、变量、方法访问，即可以被任何地方访问。
2. private：被private修饰的变量、方法只能被本类中的其他方法访问，即只能在该类的内部访问。
3. protected：被protected修饰的变量、方法可以被本类、子类、同一包中的其他类访问，即只能在该类及其子类、同一包中访问。
4. 默认（无修饰符）：如果没有指定访问修饰符，那么默认的访问修饰符是包级私有的（即同一包中的其他类可以访问该类），而其他包中的类则不能访问该类。

### Java中的异常分类以及处理方式

> 1. 编译时异常：常见的受检异常包括`IOException`、`SQLException`等。
>
>     必须进行处理可以方法内捕获或者向外抛，一般进行捕获然后抛出运行时异常
>
> 2. 运行时异常：常见的运行时异常包括`NullPointerException`、`ArrayIndexOutOfBoundsException`等。
>
>     不需要进行显式的处理
>
> 3. 错误：常见的错误包括`OutOfMemoryError`、`StackOverflowError`等。
>
>     错误无法进行捕获处理，只能由JVM或底层系统来处理。
>
> 项目中可以自定义异常，然后使用全局异常处理器进行统一的异常处理
>
> ![Java 异常类层次结构图](https://typora-1314902743.cos.ap-nanjing.myqcloud.com//interview/types-of-exceptions-in-java.png)

### 什么是内存溢出

内存溢出指的是在计算机程序中，当程序试图使用超过系统分配给它的内存量时发生的一种错误。简单来说，就是程序需要使用的内存超过了系统分配给它的内存大小。

当程序需要使用更多的内存空间，但操作系统无法为其分配足够的内存时，就会发生内存溢出。这可能会导致程序崩溃、系统运行缓慢或停止响应。内存溢出通常是由于程序设计问题、数据处理问题或者内存泄漏引起的。

解决内存溢出的方法包括增加系统内存、修改程序设计、优化代码以减少内存使用等。在编写程序时，应当考虑内存使用情况，并在程序中实现适当的内存管理来避免内存溢出的问题。

### 为什么浮点数运算的时候会有精度丢失的风险？

> 这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。
>
> // 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，
> // 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。
> 0.2 * 2 = 0.4 -> 0
> 0.4 * 2 = 0.8 -> 0
> 0.8 * 2 = 1.6 -> 1
> 0.6 * 2 = 1.2 -> 1
> 0.2 * 2 = 0.4 -> 0（发生循环）
> ...
>
> 解决办法：
>
> `BigDecimal` 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 `BigDecimal` 来做的。

### 什么是序列化?什么是反序列化?

> 如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。
>
> 注意：被static修饰的变量不会被序列化
>
> - **序列化**：将数据结构或对象转换成二进制字节流的过程
> - **反序列化**：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程
>
> ![img](https://typora-1314902743.cos.ap-nanjing.myqcloud.com//interview/a478c74d-2c48-40ae-9374-87aacf05188c.png)

### 什么是内存泄漏

内存泄漏指的是程序在运行过程中，分配的内存没有被及时地回收和释放，导致程序占用的内存越来越多，最终导致系统性能下降或者崩溃的问题。

内存泄漏通常是由于程序中存在一些内存分配和回收的错误或者不当操作导致的。例如，程序中可能存在未释放的动态内存、没有正确地释放对象引用、不合理的数据结构设计等情况。这些情况会导致一些不再使用的内存仍然占用在系统中，最终导致内存不足或者系统性能下降。

内存泄漏的后果往往是非常严重的。如果内存泄漏不及时解决，程序可能会因为内存不足而崩溃或者运行缓慢，影响用户的体验。因此，程序开发者应该非常重视内存泄漏问题，尽早检测和解决内存泄漏问题，保证程序的稳定性和性能。

### Java有自己的内存回收机制，为什么还存在内存泄漏问题

虽然Java有自己的内存回收机制，但是仍然可能存在内存泄漏问题。内存泄漏是指程序在使用内存时，由于一些原因没有及时释放已经不再使用的内存，导致内存占用越来越多，最终导致程序崩溃或者性能下降的问题。

在Java中，内存泄漏的主要原因是对象被错误的引用或保留，导致它们不能被垃圾回收机制正确地释放。下面是一些可能导致内存泄漏的常见原因：

1. 静态变量：静态变量在程序运行期间一直存在，如果静态变量引用了一个对象，那么这个对象也会一直存在，即使它已经不再需要了。
2. 长生命周期的对象：如果对象的生命周期比程序的生命周期长，那么即使程序不再使用这个对象，它也不会被垃圾回收机制回收。
3. 集合对象：如果集合对象中的元素没有正确地被删除，那么这些元素会一直占用内存。
4. 监听器和回调：如果程序中使用了监听器或回调，那么这些监听器或回调对象会被存储在某些数据结构中，如果没有正确地删除这些监听器或回调，那么它们也会导致内存泄漏。
5. 大对象：如果程序中创建了大对象，但是在使用完之后没有及时释放，那么它会占用大量的内存，导致程序的性能下降。

为了避免内存泄漏，需要在程序设计中遵循一些规范，例如：正确地使用静态变量、及时释放长生命周期的对象、正确地使用集合对象、正确地使用监听器和回调等。此外，Java中提供了一些工具可以帮助检测内存泄漏，例如jconsole和jmap等工具可以帮助查看程序中的内存使用情况，帮助排查内存泄漏问题。

### 两个线程如何共享数据

两个线程可以通过共享内存来共享数据。在多线程编程中，内存是所有线程共享的。如果一个线程修改了内存中的某个变量，其他线程也能看到这个变量的变化。

一种简单的方式是使用全局变量来共享数据。所有线程可以访问同一个全局变量，并且可以在需要时修改它。但是，这种方式有时会引发线程安全问题，因为多个线程可能会同时修改同一个变量，导致竞争条件和不可预测的行为。

为了避免这些问题，可以使用线程安全的数据结构，如锁和信号量。锁可以用来保护共享资源，确保只有一个线程在任何时刻修改它。信号量可以用来控制并发访问，确保每个线程都能安全地访问共享资源。

另外，还可以使用队列或管道等数据结构来实现线程之间的通信。一个线程可以向队列中写入数据，另一个线程可以从队列中读取数据，实现数据共享和通信。队列和管道通常是线程安全的，因此可以安全地在多个线程之间共享数据。

### Java中的弱引用

Java中的弱引用（Weak Reference）是一种特殊的引用类型，它可以让对象在没有强引用时被垃圾回收机制回收。弱引用通常用于实现缓存或者对象注册表等功能，避免因为强引用导致内存泄漏的问题。

在Java中，弱引用是通过java.lang.ref.WeakReference类来实现的。当一个对象只被弱引用所引用时，它就可以被回收。例如：

```java
Object obj = new Object();
WeakReference<Object> weakRef = new WeakReference<>(obj);
obj = null; // 将强引用置为null，让对象只被弱引用所引用
```

在上面的代码中，当obj被置为null时，对象就只被弱引用所引用了，如果垃圾回收器扫描到这个对象时发现没有强引用指向它，就会将其回收。

弱引用在实现缓存功能时非常有用，因为缓存中的对象可能会因为内存不足而被回收，而弱引用可以让这些对象在没有被使用时被回收，避免占用过多的内存空间。例如：

```java
Map<String, WeakReference<Bitmap>> cache = new HashMap<>();
...
Bitmap bitmap = ...
cache.put("key", new WeakReference<>(bitmap));
...
WeakReference<Bitmap> weakRef = cache.get("key");
Bitmap bitmap = weakRef.get();
if (bitmap == null) {
    // 对象已被回收，重新加载或者重新生成
}
```

在上面的代码中，我们使用弱引用将Bitmap对象保存在缓存中，当需要使用这个对象时，我们可以通过弱引用获取到它，如果对象已经被回收，就可以重新加载或者重新生成。这样就可以避免因为缓存中的对象占用过多的内存空间而导致程序出现OOM（Out of Memory）的问题。

需要注意的是，弱引用是非常容易被回收的，因此在使用弱引用时需要注意确保对象在使用时仍然存在，否则可能会出现NullPointerException的问题。

### Java枚举类和普通类的区别

> 枚举和普通类在Java中有一些区别，主要包括以下几个方面：
>
> 1. 实例数量：枚举类型是**有限的实例集合**，每个枚举常量都是该枚举类型的一个实例。而普通类可以创建任意数量的实例。
> 2. 单例模式：枚举类型天然地是单例模式，枚举常量是唯一的实例。因此，枚举类型的实例是线程安全的，可以直接使用相等运算符（`==`）进行比较。
> 3. 构造方法：枚举类的构造方法是私有的
> 4. 继承和接口实现：枚举类不能继承类但可以实现接口
> 5. switch语句支持：枚举类型可以在switch语句中使用，每个枚举常量都对应一个分支。普通类不能在switch语句中使用。
>
> 使用场景：可以使用枚举类定义Http状态码

## 七、服务器

### HTTP 与 HTTPS 有什么区别

HTTP（超文本传输协议）和HTTPS（安全超文本传输协议）是用于在Web服务器和Web浏览器之间传输数据的协议。它们之间的**主要区别在于安全性**。

HTTP是一种明文协议，意味着在传输过程中，数据以明文形式传输，容易被黑客窃取或篡改。HTTPS则使用加密技术对数据进行加密，使得传输过程中的数据无法被黑客窃取或篡改，从而保证数据的安全。

具体来说，HTTPS使用**SSL（安全套接层）或TLS（传输层安全）协议来加密数据**。在建立连接时，服务器会将自己的数字证书发送给浏览器。浏览器会验证证书的有效性，并使用证书中的公钥来加密数据。服务器收到加密后的数据后，使用私钥进行解密。

除了安全性，HTTPS还可以提高网站的SEO排名，因为搜索引擎更喜欢安全的网站，并且许多浏览器也会标记非HTTPS网站为不安全。然而，HTTPS通信需要更多的计算资源和时间，因此可能会稍微减慢网站的速度。

总之，HTTP和HTTPS都是用于在Web服务器和Web浏览器之间传输数据的协议，但HTTPS比HTTP更安全，更受欢迎，但也需要更多的计算资源和时间。

### HTTPS 的加密具体过程

HTTPS 使用 SSL 或 TLS 协议来加密数据传输，其加密具体过程如下：

1. 客户端发送一个连接请求给服务器，请求使用 HTTPS 协议进行通信。
2. 服务器将自己的公钥和数字证书发送给客户端。
3. 客户端验证数字证书的合法性，包括证书是否过期、是否由可信的证书颁发机构颁发等。
4. 客户端生成一个随机数，称为“对称密钥”，用于后续的数据加密。
5. 客户端使用服务器的公钥对“对称密钥”进行加密，并发送给服务器。
6. 服务器使用自己的私钥对加密后的“对称密钥”进行解密。
7. 客户端和服务器都使用“对称密钥”来加密和解密数据，这样可以保证数据传输的机密性和完整性。
8. 在数据传输过程中，客户端和服务器使用“对称密钥”来加密和解密数据，使用MAC（消息认证码）来保证数据的完整性，使用数字签名来验证数据的真实性。
9. 通信结束后，客户端和服务器都将“对称密钥”丢弃，从而保证下一次通信的安全性。

> 服务器	公钥和数字证书 ---->	客户端
>
> 客户端	验证数字证书	利用公钥加密
>
> 服务端	利用私钥解密

### HTTP 有哪些常见的状态码？

HTTP（Hypertext Transfer Protocol）是一种基于请求/响应模型的应用层协议，常用于Web应用中。在HTTP通信中，状态码用于表示服务器对请求的处理结果。

常见的HTTP状态码包括以下几种：

1. 1xx（信息性状态码）：表示请求已经接收，正在处理中。
2. 2xx（成功状态码）：表示请求已经被成功接收、理解和处理。
    - 200 OK：表示请求已经成功处理。
    - 201 Created：表示请求已经被成功处理，并且服务器创建了新的资源。
    - 204 No Content：表示请求已经被成功处理，但是响应中没有返回任何实体内容。
3. 3xx（重定向状态码）：表示需要进行进一步操作才能完成请求。
    - 301 Moved Permanently：表示所请求的资源已经永久移动到新位置。
    - 302 Found：表示所请求的资源已经临时移动到新位置。
    - 304 Not Modified：表示客户端缓存的资源是最新的，可以直接使用缓存。
4. 4xx（客户端错误状态码）：表示请求出现了错误，服务器无法处理。
    - 400 Bad Request：表示请求语法错误，服务器无法处理该请求。
    - 401 Unauthorized：表示请求需要进行身份认证，但是客户端没有提供有效的身份证明。
    - 403 Forbidden：表示服务器拒绝处理请求，权限不足。
    - 404 Not Found：表示所请求的资源不存在。
5. 5xx（服务器错误状态码）：表示服务器在处理请求时发生了错误。
    - 500 Internal Server Error：表示服务器在处理请求时发生了内部错误。
    - 502 Bad Gateway：表示服务器作为网关或代理角色时，接收到的响应是无效的。
    - 503 Service Unavailable：表示服务器暂时无法处理请求，一般是由于服务器过载或正在维护。

### HTTP 是哪一层的协议？简述它的作用？

HTTP（Hypertext Transfer Protocol）是应用层协议，它建立在TCP/IP协议之上，是互联网上应用最广泛的协议之一。HTTP主要用于在Web浏览器和Web服务器之间传递信息，它定义了客户端和服务器之间通信的规范和方式。

HTTP的作用主要有以下几个方面：

1. 客户端和服务器之间的通信：HTTP定义了客户端和服务器之间如何进行通信，包括请求格式、响应格式、数据编码方式等。
2. 资源定位：HTTP协议支持在Web上定位并传输各种资源，如HTML页面、图片、音频、视频等。
3. 安全性：HTTP协议定义了一些安全机制，如HTTPS，可以对通信过程进行加密，确保通信的安全性。
4. 缓存和代理：HTTP协议支持浏览器缓存机制和代理服务器，能够提高网络传输效率，降低网络负载。

总之，HTTP协议在Web应用中扮演着至关重要的角色，它使得客户端和服务器之间的通信变得简单、高效、安全，并且能够支持各种各样的网络应用。

### 浏览器输入一个网址之后的过程（包括服务端怎样处理）？

当用户在浏览器中输入一个网址时，网页的加载过程通常包括以下几个步骤：

1. **DNS 解析**：浏览器首先会将网址中的域名发送给 DNS 服务器，获取该域名对应的 IP 地址。
2. **建立 TCP 连接**：浏览器使用获取到的 IP 地址和端口号与服务器建立 TCP 连接。
3. **发送 HTTP 请求**：浏览器向服务器发送 HTTP 请求，包括请求方法、请求头、请求体等信息。
4. **服务器处理请求**：服务器接收到浏览器发送的 HTTP 请求后，根据请求信息进行处理，例如查找数据库、生成动态内容等。
5. **返回 HTTP 响应**：服务器将处理结果封装成 HTTP 响应，包括响应头、响应体等信息，发送给浏览器。
6. **浏览器渲染页面**：浏览器接收到服务器返回的 HTTP 响应后，根据响应内容进行页面的渲染，包括解析 HTML、CSS 和 JavaScript 等内容，构建页面 DOM 树，展示页面内容。
7. **断开 TCP 连接**：当页面加载完成后，浏览器会断开与服务器的 TCP 连接，释放资源。

需要注意的是，以上过程可能会受到网络环境、服务器性能等因素的影响，导致页面加载时间过长或页面无法正常显示。为了提高用户体验和网站性能，需要优化页面加载过程，例如使用 CDN 加速、压缩页面内容、使用缓存等技术手段。

### TCP和UDP的区别

TCP（Transmission Control Protocol）和 UDP（User Datagram Protocol）是两种常用的网络传输协议，它们有以下几个方面的区别：

1. 连接方式：TCP 是面向连接的协议，需要**先建立连接，**然后才能进行数据传输，而 UDP 则是**无连接**的协议，数据传输前不需要建立连接。
2. 可靠性：TCP 提供可靠的数据传输，通过数据重传、错误校验等机制保证数据的完整性和准确性，而 UDP 则不提供可靠性保障，数据传输可能会丢失或重复。
3. 速度：TCP 为了保证可靠性，有较多的控制和确认机制，导致传输速度较慢，而 UDP 的传输速度较快，因为没有请求确认机制。
4. 数据包大小：TCP 数据包大小没有限制，可以根据网络状况自动调整，而 **UDP 数据包大小有限制，最大只能达到 64KB**。
5. 适用场景：TCP 适用于对数据可靠性要求较高的场景，例如网页浏览、文件传输等；而 UDP 适用于对实时性要求较高的场景，例如视频直播、在线游戏等。

### TCP 为什么要三次握手

TCP（传输控制协议）是一种面向连接的协议，建立连接时需要进行三次握手，以确保连接的可靠性和稳定性。

具体来说，TCP 三次握手的过程如下：

1. 第一次握手（SYN）：客户端发送一个 SYN 包，表示请求建立连接，并选择一个初始序列号 seq。
2. 第二次握手（SYN+ACK）：服务器收到 SYN 包后，如果同意建立连接，就发送一个 SYN+ACK 包作为应答，并选择一个初始序列号 seq，以及确认号 ack=客户端的 seq+1。
3. 第三次握手（ACK）：客户端收到 SYN+ACK 包后，发送一个 ACK 包作为应答，确认收到服务器的 SYN+ACK 包，并将确认号 ack=服务器的 seq+1。

完成了这个三次握手过程后，连接就建立起来了，客户端和服务器就可以开始进行数据传输了。

为什么需要三次握手呢？主要是为了保证可靠性和稳定性，具体原因如下：

1. 避免因为网络延迟导致的重复连接：如果只有两次握手，那么客户端发送的 SYN 包可能会因为网络延迟而延迟到服务器收到之前，这样服务器可能会误认为客户端发送了两个独立的连接请求，从而建立了两个连接，这样就会导致数据传输的混乱。
2. 避免因为网络延迟导致的连接失败：如果只有两次握手，那么客户端发送的 SYN 包可能会因为网络延迟而延迟到服务器收到之后，这样客户端可能会误认为连接已经建立，开始发送数据，但是服务器可能并没有收到客户端的 SYN 包，从而导致连接失败。
3. 防止已经失效的连接请求报文段突然又传送到了服务端，因而产生错误。

因此，TCP 采用三次握手的方式来建立连接，可以确保连接的可靠性和稳定性，避免数据传输的混乱和失败。

### TCP 四次挥手是什么样的

TCP（传输控制协议）是一种面向连接的协议，在完成数据传输后需要进行四次挥手，以确保连接的正常关闭。

TCP 四次挥手的过程如下：

1. 第一次挥手（FIN）：客户端发送一个 FIN 包，表示数据发送完毕，请求关闭连接。
2. 第二次挥手（ACK）：服务器收到 FIN 包后，发送一个 ACK 包作为应答，确认收到客户端的 FIN 包。
3. 第三次挥手（FIN）：服务器发送一个 FIN 包，表示数据接收完毕，请求关闭连接。
4. 第四次挥手（ACK）：客户端收到 FIN 包后，发送一个 ACK 包作为应答，确认收到服务器的 FIN 包。此时客户端和服务器都完成了数据传输并关闭了连接。

需要注意的是，第一次挥手和第二次挥手是一个组合，表示客户端请求关闭连接并等待服务器的应答；第三次挥手和第四次挥手也是一个组合，表示服务器确认关闭连接并等待客户端的应答。因此，四次挥手过程实际上是两个“两次挥手”的组合。

为什么需要四次挥手呢？这是因为 TCP 是一种面向连接的协议，建立连接时需要进行三次握手，而关闭连接时则需要四次挥手。具体原因如下：

1. 客户端发送完最后一个数据包后，需要等待服务器的确认，确认收到后才能关闭连接，因此需要第一次挥手和第二次挥手。
2. 服务器在收到客户端的请求后，可能还需要一些时间来处理数据，可能还需要发送一些数据，因此需要第三次挥手和第四次挥手。
3. 在关闭连接时，可能还有一些数据在传输过程中，需要确保数据传输完整，因此需要四次挥手来完成数据传输和关闭连接。

因此，TCP 四次挥手是一种保证连接正常关闭的机制，可以确保数据传输的可靠性和稳定性。

## 八、MyBatis

### 什么是MyBatis

> MyBatis是半自动化持久层框架（ORM 对象关系映射）
>
> - 封装了JDBC，`简化`了对数据库的访问，减少繁杂的JDBC代码编写
> - 实现SQL与Java代码的`解耦`，JDBC的SQL编写是与Java程序绑定在一起的
> - 支持定制化SQL的编写和高级映射

### MyBatis执行流程

> ![image-20230606230637049](https://raw.githubusercontent.com/njauwj/java-note/master/202308102208411.png)
>
> 

### MyBatis延迟加载

> 延迟加载的意思是：就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。
>
> Mybatis支持一对一关联对象和一对多关联集合对象的延迟加载
>
> 在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false，默认是关闭的
>
> ![image-20230608224739992](https://raw.githubusercontent.com/njauwj/java-note/master/202308102208975.png)

### MyBatis缓存

> 一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当Session进行flush或close之后，该Session中的所有Cache就将清空，默认打开一级缓存
>
> 二级缓存是基于namespace和mapper的作用域（一个mapper对应一个缓存）起作用的，不是依赖于SQL session，默认也是采用 PerpetualCache，HashMap 存储。需要单独开启，一个是核心配置，一个是mapper映射文件
>
> 当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了新增、修改、删除操作后，默认该作用域下所有 select 中的缓存将被 clear。

### #{}和${}的区别

> 1. **`#{}`（安全占位符）：**底层是PreparedStatement实现
>     - `#{}` 用于表示 SQL 查询的参数占位符，参数值会自动进行预编译，以防止 SQL 注入。
>     - `#{}` 可以自动处理参数类型的转换，确保传递的参数类型正确。
> 2. **`${}`（字符串替换）：**底层是Statement实现
>     - `${}` 表示字符串替换，参数值会直接替换到 SQL 语句中，不会进行预编译。
>     - `${}` 不会自动进行类型转换，需要手动处理参数的类型和格式，容易引发类型错误或其他问题。
>     - `${}` 在 SQL 语句中直接嵌入参数值，有潜在的 SQL 注入风险，不如 `#{}` 安全。
>
> ```sql
> select * from user where account = #{account};
> # userMapper.getUser("test")
> #使用#{account} 结果为 select * from user where account = 'test';
> #使用${account} 结果为 select * from user where account = test; 此时语法报错
> #解决办法 userMapper.getUser(" 'test' ") 或者  '${account}'
> #SQL注入示例 userMapper.getUser(" 'abc' or 1 = 1 ") 结果如下
> # select * from user where account = 'abc' or 1 = 1;
> ```

### 使用mybatis时当实体类与表字段名字不一样时怎么处理

当实体类与表字段名字不一样时，可以使用MyBatis的映射机制来解决这个问题。MyBatis提供了两种映射方式：

1. 使用XML文件配置映射关系：在MyBatis的XML文件中可以使用resultMap元素来配置实体类和表字段之间的映射关系。可以使用column元素来指定表字段的名称，使用property元素来指定实体类的属性名。

例如，如果实体类中的属性名为userName，而表中的字段名为user_name，可以在resultMap中这样配置：

```xml
<select id="getOrder" parameterType="int" resultMap="orderresultmap">
select * from orders where order_id=#{id}
</select>
<resultMap type=”me.gacl.domain.order” id=”orderresultmap”>
<!–用id属性来映射主键字段–>
<id property=”id” column=”order_id”>
<!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–>
<result property = “orderno” column =”order_no”/>
<result property=”price” column=”order_price” />
</reslutMap>
```

2. 使用注解配置映射关系：MyBatis也支持使用注解来配置实体类和表字段之间的映射关系。可以在实体类中使用@Results和@Result注解来指定表字段和属性之间的对应关系。

例如，如果实体类中的属性名为userName，而表中的字段名为user_name，可以在实体类中这样配置：

```java
@Results({
  @Result(column = "user_name", property = "userName")
})
public class User {
  //属性
}
```

在以上两种方式中，都可以使用别名来简化配置，使得配置更加简洁。例如，可以在XML文件或注解中使用column属性的别名，来代替表字段的真实名称。

使用MyBatis的映射机制，可以让实体类与表字段之间的映射关系更加灵活和可定制化，从而提高开发效率和代码质量。

> 1. 使用sql语句的别名机制 如 select user_id id from user
> 2. 使用resultMap 进行关系映射
> 3. 使用注解配置映射关系

### MyBatis是如何进行分页的，分页插件原理是什么

MyBatis提供了一种方便的方式来进行分页查询，其原理是在SQL语句中添加LIMIT子句来限制查询结果的数量。在MySQL中，LIMIT子句的语法格式为LIMIT offset, count，其中offset表示查询结果的起始位置，count表示查询结果的数量。通过设置offset和count的值，可以实现分页查询。

例如，如果需要查询第2页，每页显示10条记录的用户列表，可以在SQL语句中添加LIMIT子句，如下所示：

```sql
SELECT * FROM user LIMIT 10 OFFSET 10;
```

这条SQL语句表示从表user中查询第2页的用户列表，起始位置为10，数量为10。

为了方便地进行分页查询，MyBatis还提供了一个分页插件，可以简化分页查询的代码。分页插件的原理是在执行SQL查询之前，拦截查询请求，根据分页参数重新构造SQL语句，然后执行查询并返回查询结果。分页插件通常需要实现以下三个接口：

1. Interceptor：拦截器接口，用于拦截查询请求。

2. Executor：执行器接口，用于执行SQL查询。

3. ParameterHandler：参数处理器接口，用于处理分页参数。

分页插件的使用方法如下：

1. 定义分页插件：创建一个实现Interceptor接口的类，实现intercept方法，在该方法中处理分页请求。

```java
public class PageInterceptor implements Interceptor {
  @Override
  public Object intercept(Invocation invocation) throws Throwable {
    //处理分页请求
    return invocation.proceed();
  }
}
```

2. 配置分页插件：在MyBatis的配置文件中，将分页插件配置为插件链的一部分。

```xml
<plugins>
  <plugin interceptor="com.example.PageInterceptor"/>
</plugins>
```

3. 使用分页查询：在Mapper接口中定义分页查询方法，使用@Param注解来指定分页参数。

```java
public interface UserMapper {
  List<User> selectUsers(@Param("start") int start, @Param("pageSize") int pageSize);
}
```

在SQL语句中使用limit和offset来实现分页查询。

```xml
<select id="selectUsers" resultMap="userMap">
  SELECT * FROM user LIMIT #{pageSize} OFFSET #{start}
</select>
```

通过以上步骤，即可使用MyBatis提供的分页插件来实现分页查询。分页插件的原理是拦截查询请求，根据分页参数重新构造SQL语句，然后执行查询并返回查询结果，从而实现分页查询功能。

## 九、业务

### 什么是一致性Hash

> https://www.xiaolincoding.com/os/8_network_system/hash.html#%E4%BD%BF%E7%94%A8%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98
>
> 轮询这类的策略只能适用与每个节点的数据都是相同的场景，访问任意节点都能请求到数据。但是不适用分布式系统，因为分布式系统意味着数据水平切分到了不同的节点上，访问数据的时候，一定要寻址存储该数据的节点。(例如水平分表)
>
> 哈希算法虽然能建立数据和节点的映射关系，但是每次在节点数量发生变化的时候，最坏情况下所有数据都需要迁移，这样太麻烦了，所以不适用节点数量变化的场景。
>
> 为了减少迁移的数据量，就出现了一致性哈希算法。
>
> 一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的`哈希环`上，如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响。
>
> 但是一致性哈希算法不能够均匀的分布节点，会出现大量请求都集中在一个节点的情况，在这种情况下进行容灾与扩容时，容易出现雪崩的连锁反应。
>
> 为了解决一致性哈希算法不能够均匀的分布节点的问题，就需要引入虚拟节点，对一个真实节点做多个副本。不再将真实节点映射到哈希环上，而是将`虚拟节点`映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有「两层」映射关系。
>
> 引入虚拟节点后，可以会提高节点的均衡度，还会提高系统的稳定性。所以，带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景。

## 十、设计模式

### 工厂模式

工厂模式（Factory Pattern）是一种创建对象的设计模式，它提供了一种将对象的实例化过程封装在工厂类中的方式。通过工厂模式，我们可以**将对象的创建和使用解耦**，使代码更加灵活和可维护。

工厂模式的主要目的是将对象的实例化过程从客户端代码中抽离出来，使客户端代码不需要直接依赖具体的类，而是通过工厂类来创建对象。这样可以隐藏对象创建的细节，使客户端代码更加简洁和可复用。

工厂模式通常涉及以下几个角色：

1. 抽象产品（Abstract Product）：定义了产品的抽象接口，客户端通过该接口操作产品的统一方法。
2. 具体产品（Concrete Product）：实现了抽象产品接口，是工厂所创建的对象。
3. 抽象工厂（Abstract Factory）：定义了创建产品的抽象方法，客户端通过该接口创建具体产品的实例。
4. 具体工厂（Concrete Factory）：实现了抽象工厂接口，负责创建具体产品的实例。

工厂模式的核心思想是将对象的创建委托给工厂类，客户端代码只需要和工厂接口打交道，而不需要直接与具体的产品类耦合。这样，如果需要更换具体产品类，只需调整工厂类的实现，而不需要修改客户端代码。

工厂模式可以提供很好的可扩展性和灵活性，使系统更易于维护和扩展。常见的工厂模式包括**简单工厂模式**、**工厂方法模式**和**抽象工厂模式**，它们在对象的创建和使用方式上有所区别，但都遵循了将对象创建和使用分离的原则。

- 简单工厂模式（Simple Factory Pattern）

    ```java
    // 抽象产品
    interface Product {
        void operation();
    }
    // 具体产品 A
    class ConcreteProductA implements Product {
        public void operation() {
            System.out.println("ConcreteProductA operation");
        }
    }
    // 具体产品 B
    class ConcreteProductB implements Product {
        public void operation() {
            System.out.println("ConcreteProductB operation");
        }
    }
    // 简单工厂类
    class SimpleFactory {
        public static Product createProduct(String type) {
            if (type.equals("A")) {
                return new ConcreteProductA();
            } else if (type.equals("B")) {
                return new ConcreteProductB();
            }
            return null;
        }
    }
    // 客户端代码
    public class MainApp {
        public static void main(String[] args) {
            // 使用简单工厂创建产品
            Product productA = SimpleFactory.createProduct("A");
            productA.operation();
            
            Product productB = SimpleFactory.createProduct("B");
            productB.operation();
        }
    }
    ```

- 工厂方法模式（Factory Method Pattern）

    ```java
    // 抽象产品
    interface Product {
        void operation();
    }
    
    // 具体产品 A
    class ConcreteProductA implements Product {
        public void operation() {
            System.out.println("ConcreteProductA operation");
        }
    }
    
    // 具体产品 B
    class ConcreteProductB implements Product {
        public void operation() {
            System.out.println("ConcreteProductB operation");
        }
    }
    
    // 抽象工厂
    interface Factory {
        Product createProduct();
    }
    
    // 具体工厂 A
    class ConcreteFactoryA implements Factory {
        public Product createProduct() {
            return new ConcreteProductA();
        }
    }
    
    // 具体工厂 B
    class ConcreteFactoryB implements Factory {
        public Product createProduct() {
            return new ConcreteProductB();
        }
    }
    
    // 客户端代码
    public class MainApp {
        public static void main(String[] args) {
            // 使用具体工厂 A 创建产品
            Factory factoryA = new ConcreteFactoryA();
            Product productA = factoryA.createProduct();
            productA.operation();
    
            // 使用具体工厂 B 创建产品
            Factory factoryB = new ConcreteFactoryB();
            Product productB = factoryB.createProduct();
            productB.operation();
        }
    }
    ```

- 抽象工厂模式（Abstract Factory Pattern）

    ```java
    public interface Product {
        void operation();
    }
    public class ConcreteProductA implements Product {
        @Override
        public void operation() {
            System.out.println("Product A operation");
        }
    }
    
    public class ConcreteProductB implements Product {
        @Override
        public void operation() {
            System.out.println("Product B operation");
        }
    }
    public interface AbstractFactory {
        Product createProduct();
    }
    public class ConcreteFactoryA implements AbstractFactory {
        @Override
        public Product createProduct() {
            return new ConcreteProductA();
        }
    }
    
    public class ConcreteFactoryB implements AbstractFactory {
        @Override
        public Product createProduct() {
            return new ConcreteProductB();
        }
    }
    public class Main {
        public static void main(String[] args) {
            // 使用具体工厂A创建产品
            AbstractFactory factoryA = new ConcreteFactoryA();
            Product productA = factoryA.createProduct();
            productA.operation();
    
            // 使用具体工厂B创建产品
            AbstractFactory factoryB = new ConcreteFactoryB();
            Product productB = factoryB.createProduct();
            productB.operation();
        }
    }
    
    ```

### 单例模式

单例模式是一种常用的创建型设计模式，它的主要目的是确保一个类最多只有一个实例，并提供一个全局访问点供外部程序访问该实例。

单例模式的实现通常包括以下几个要素：

1. 私有构造函数：将该类的构造函数设为私有，从而防止其他类通过 new 操作符创建该类的实例。
2. 静态方法或变量：为了可以在类的外部访问该类的唯一实例，通常会提供一个静态方法或变量来获取该实例。
3. 延迟加载：为了避免在程序启动时就创建该类的实例，并占用系统资源，通常会采用延迟加载的方式，在第一次使用时才创建该类的实例。
4. 线程安全：由于单例模式只允许创建一个实例，因此需要考虑多线程并发访问的情况，通常可以采用双重检查锁或者静态内部类等方式来确保线程安全。

单例模式的主要优点是：

1. 节省系统资源：由于单例模式只创建一个实例，可以避免重复创建对象所消耗的系统资源，从而提高系统的性能和响应速度。
2. 提高代码复用性：由于单例模式的实例可以在多个模块中共享，可以提高代码的复用性，并降低代码的耦合度。
3. 简化对象管理：由于单例模式只创建一个实例，可以简化对象的管理和维护，使系统更加易于理解和维护。

但是，单例模式也有一些缺点，例如：

1. 违反单一职责原则：由于单例模式既负责创建对象，又负责管理对象，因此可能违反单一职责原则。
2. 破坏可测试性：由于单例模式创建的对象通常是全局可访问的，因此可能会破坏代码的可测试性，使得测试变得更加困难。
3. 难以扩展：由于单例模式只允许创建一个实例，因此扩展性较差，如果需要创建更多的实例，就需要修改现有的代码，从而增加了系统的复杂度。

总的来说，单例模式可以在需要确保某个类只有一个实例且全局唯一访问点的场景下，提供一种简单、可靠且高效的解决方案。在实现单例模式时，需要根据实际情况选择适合的实现方式，并注意线程安全和可测试性等问题。

```java
//示例代码 
public class Logger {
    private static Logger instance = null;

    private Logger() {
        // 私有构造函数，防止其他类通过 new 操作符创建该类的实例
    }

    public static synchronized Logger getInstance() {
        if (instance == null) {
            // 延迟加载，第一次使用时才创建该类的实例
            instance = new Logger();
        }
        return instance;
    }

    public void log(String message) {
        // 实现日志功能
        System.out.println("Log: " + message);
    }
}
```

## 十一、微服务

### SpringCloud的五大组件

> ![image-20230608231549955](https://raw.githubusercontent.com/njauwj/java-note/master/image-20230608231549955.png)
>
> ![image-20230608231632001](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230608231632001.png)

### 注册中心

> 注册中心的核心作用是：服务注册和发现
>
> 常见的注册中心：eureka、nocas、zookeeper
>
> **eureka**
>
> ![image-20230608233002021](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230608233002021.png)
>
> **服务注册**：服务提供者需要把自己的信息注册到eureka，由eureka来保存这些信息，比如服务名称、ip、端口等等
>
> **服务发现**：消费者向eureka拉取服务列表信息，如果服务提供者有集群，则消费者会利用负载均衡算法，选择一个发起调用
>
> **服务监控**：服务提供者会每隔30秒向eureka发送心跳，报告健康状态，如果eureka服务90秒没接收到心跳，从eureka中剔除
>
> **nacos**
>
> ![image-20230608233147724](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230608233147724.png)
>
> Nacos与eureka的共同点（注册中心）
>
> ①都支持服务注册和服务拉取
>
> ②都支持服务提供者心跳方式做健康检测
>
> Nacos与Eureka的区别（注册中心）
>
> ①Nacos支持服务端主动检测提供者状态：临时实例（默认）采用心跳模式，非临时实例采用主动检测模式
>
> ②临时实例心跳不正常会被剔除，非临时实例则不会被剔除
>
> ③Nacos支持服务列表变更的消息推送模式，服务列表更新更及时
>
> ④Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式
>
> Nacos还支持了配置中心，eureka则只有注册中心，也是选择使用nacos的一个重要原因

### 负载均衡

> 微服务的负载均衡主要使用了一个组件Ribbon，比如，我们在使用feign远程调用的过程中，底层的负载均衡就是使用了ribbon
>
> ![image-20230608234312110](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230608234312110.png)
>
> ![image-20230608234336344](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230608234336344.png)
>
> ![image-20230608234352993](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230608234352993.png)
>
> @Bean:针对所有远程调用服务都生效
>
> 配置文件：只有调用userservice服务才会使用

### 什么是服务雪崩

> 服务雪崩：一个服务失败，导致整条链路的服务都失败的情形
> 服务降级：服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃，一般在实际开发中与feign接口整合，编写降级逻辑（针对接口，服务的其他接口仍可以正常访问）
> 服务熔断：默认关闭，需要手动打开，如果检测到 10 秒内请求的失败率超过 50%，就触发熔断机制。之后每隔 5 秒重新尝试请求微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求，（针对整个服务，发送熔断后整个服务都不可用）
>
> ![image-20230609222708214](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230609222708214.png)
>
> ![image-20230609223008852](C:\Users\WinX PRO\AppData\Roaming\Typora\typora-user-images\image-20230609223008852.png)

### 微服务监控

> 监控的作用：微服务之间的调用错综复杂
>
> 问题定位：快速定位出现问题的服务
> 性能分析：分析每个服务的响应时间
> 服务关系：服务之间的调用关系
> 服务告警：触发告警规则主动告警通知
>
> skywalking
>
> 一个分布式系统的应用程序性能监控工具（ Application Performance Managment ），提供了完善的链路追踪能力， apache的顶级项目（前华为产品经理吴晟主导开源）
>
> 我们项目中采用的skywalking进行监控的
> 1，skywalking主要可以监控接口、服务、物理实例的一些状态。特别是在压测的时候可以看到众多服务中哪些服务和接口比较慢，我们可以针对性的分析和优化。
> 2，我们还在skywalking设置了告警规则，特别是在项目上线以后，如果报错，我们分别设置了可以给相关负责人发短信和发邮件，第一时间知道项目的bug情况，第一时间修复

## 十二、并发编程

### 线程与进程的区别

> 进程：程序的一次执行过程，是系统运行程序的基本单位
>
> 线程：进程的执行单元，一个进程包含多个线程
>
> 从下图可以看出：一个进程中可以有多个线程，多个线程共享进程的**堆**和**方法区 (JDK1.8 之后的元空间)\**资源，但是每个线程有自己的\**程序计数器**、**虚拟机栈** 和 **本地方法栈**。
>
> ![Java 运行时数据区域（JDK1.8 之后）](https://raw.githubusercontent.com/njauwj/java-note/master/java-runtime-data-areas-jdk1.8.png)

### 线程的程序计数器

> 用于存储当前线程**正在执行的字节码指令的地址或索引**。每个线程都有自己独立的程序计数器，它在线程切换时会被保存和恢复。
>
> 简单来说就是记录当前线程执行到哪了，因为线程之间是会切换的，所以需要知道之前执行到哪一步了。这也是为什么程序计算器是线程私有的

### 线程的本地方法栈

> 用于用于存储本地方法（`Native`）的调用和执行相关信息。

### 线程的虚拟机栈

> 每个 Java 方法在执行之前会创建一个`栈帧`用于存储`局部变量表`、`操作数栈`、`常量池引用`等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
>
> 虚拟机栈和本地方法栈是类似的，一个管理Native方法，一个管理Java方法。

### 并行和并发的区别

> 并发：多个任务在同一时间段执行，cpu得来回切换执行这些任务
>
> 并行：多个任务在同一时刻同时执行，多核cpu可以实现并行，cpu不需要切换

### 创建线程的方式

> 继承Thread类
>
> 实现runnable接口
>
> 实现Callable接口
>
> 线程池创建线程
>
> runnable 和 callable 有什么区别:
>
> 1. Runnable 接口run方法没有返回值
>
> 2. Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果
>
> 3. Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛
>
> 线程的 run()和 start()有什么区别:
>
> 1. start(): 用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。
> 2. run(): 封装了要被线程执行的代码，可以被调用多次。

### 线程的六大状态

> Thread类里面有一个内部枚举State记录了这六个状态
>
> NEW: 初始状态，线程被创建出来但没有被调用 `start()` 。
>
> RUNNABLE: 运行状态，线程被调用了 `start()`等待运行的状态。
>
> BLOCKED：阻塞状态，需要等待锁释放。
>
> WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。
>
> TIME_WAITING：计时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。
>
> TERMINATED：终止状态，表示该线程已经运行完毕。
>
> ![Java线程的6种状态及切换(透彻讲解)_线程状态_潘建南的博客-CSDN博客](https://raw.githubusercontent.com/njauwj/java-note/master/20181120173640764.jpeg)

### 什么是线程上下文切换

>上下文切换：
>
>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换**。
>
>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。
>
>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。

### 什么是线程死锁

> 两个线程或者多个线程**同时等待对方释放资源**，从而导致所有线程都无法继续执行，陷入无限等待的状态
>
> ![image-20230802210136747](https://raw.githubusercontent.com/njauwj/java-note/master/image-20230802210136747.png)

### 如何避免线程死锁

> - 尽量避免一个线程使用多个锁
> - 所有线程获取锁的顺序保持一致
> - 使用可重入锁，避免线程等待自己的情况

### 多个线程如何保证执行顺序

> 使用 Thread 中的 join 方法
>
> ```java
> thread1 {
>     //只有当thread2执行完了thread1才能继续往下执行
>     thread2.join()
>     ...
> }
> ```

### notify和notifyAll的区别

> 两者都是 Object 里的方法
>
> notify：随机唤醒一个正在 wait 的线程
>
> notifyAll：唤醒所有正在 wait 的线程

### wait 和 sleep 的区别

> **共同点**
>
> wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入`等待状态`
>
> **不同点**
>
> 1. 方法归属不同
>
>     sleep(long) 是 Thread 的静态方法
>
>     而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有
>
> 2. 醒来时机不同
>
>     执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来
>
>     wait(long) 和 wait() 还可以被 `notify` 唤醒，wait() 如果不唤醒就一直等下去
>
>     它们都可以被打断唤醒
>
> 3. **锁特性不同**（重点）
>
>     wait 方法的调用必须先获取 wait 对象的锁,必须配合 Synchronized 使用否者会报错，而 sleep 则无此限制
>
>     wait 方法执行后`会释放对象锁`，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）
>
>     而 sleep 如果在 synchronized 代码块中执行，并`不会释放对象锁`（我放弃 cpu，你们也用不了）

### 如何停止一个运行的线程

> 有三种方式可以停止线程
>
> 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止
>
> 使用stop方法强行终止（不推荐，方法已作废）
>
> 使用interrupt方法中断线程
>
> - 打断阻塞的线程（ sleep，wait，join ）的线程，线程会抛出InterruptedException异常
>
> - 打断正常的线程，可以根据打断状态来标记是否退出线程
>
> ```java
> 使用退出标志和打断正常的线程本质是一样的，核心:
> boolean flag = true
> thread{
>     while(flag) {
>         ...
>     }
> }
> ...
> flag = false;
> Thread调用interrupt方法后
> public boolean isInterrupted()会返回true，默认是false
> thread{
>     while(true) {
>         boolean flag = thread.isInterrupted();
>         if(flag) {
>             break;
>         }
>         ...
>     }
> }
> thread.interrupt();
> ```

### 为什么不能直接调用run方法启动线程？

> 直接调用run方法，run方法会在当前线程执行，并不会创建新的线程
>
> 调用start方法，实际上是通知java虚拟机创建一个新的线程，在新的线程执行run方法

### synchronized 底层原理

> ![image-20230612231344378](https://raw.githubusercontent.com/njauwj/java-note/master/image-20230612231344378.png)
>
> 当调用 lock.notify()就是从 WaitSet 里随机唤醒一个
>
> 每一个锁对象关联一个Monitor

### JMM（java内存模型）

> JMM（Java Memory Model）是Java内存模型的缩写。它是一种规范，**定义了Java虚拟机（JVM）如何在多线程环境下与主内存、工作内存进行交互**，以及如何保证线程之间的内存可见性、顺序性和原子性。
>
> JMM把内存分为两块，一块是私有线程的工作区域（工作内存），一块是所有线程的共享区域（主内存）
>
> 线程跟线程之间是相互隔离，线程跟线程交互需要通过主内存
>
> ![image-20230628203504050](https://raw.githubusercontent.com/njauwj/java-note/master/image-20230628203504050.png)

### 乐观锁

> 乐观锁认为共享资源被访问的时候不会出现问题，只在提交的时候去验证资源是否被其他问题修改了，常见的实现方案有
>
> `版本号`法和`CAS`法
>
> `CAS`（Compare and Swap）是一种并发算法，用于实现多线程环境下的原子操作。CAS操作通常用于解决并发环境下的数据同步和线程安全性问题。CAS是基于乐观锁的思想，而synchronized 是基于悲观锁的思想
>
> CAS算法包含三个操作数：`内存地址V`、`旧的预期值A`和`新的值B`。它的执行过程如下：
>
> 1. 检查内存地址V中的值是否等于预期值A，如果相等，则执行步骤2；如果不相等，则说明其他线程已经修改了V的值，此时CAS失败，返回false。
> 2. 将内存地址V的值设置为新的值B。如果成功设置，说明CAS操作成功，返回true；如果失败，说明其他线程又修改了V的值，返回false。
>
> **CAS操作（比较的过程）是`原子性`**的，即在执行过程中不会被其他线程中断。它利用硬件的原子指令（比如CPU提供的CMPXCHG指令），在执行时不需要加锁，因此具有较低的开销和较高的性能
>
> CAS存在`ABA`问题:
>
> 在ABA问题中，有三个线程参与操作：
>
> 1. 线程T1首先读取共享变量A的值为"X"。
> 2. 线程T2执行CAS操作，将A的值从"X"改为"Y"。
> 3. 线程T3执行CAS操作，将A的值从"Y"又改回"X"。
>
> 此时，线程T1再次执行CAS操作时，会发现A的值与之前读取的值相同，虽然它并没有发现在此期间A的值曾经被改变过。因此，CAS操作成功，但实际上A的值已经被线程T2和线程T3交替修改过，线程T1并没有感知到这一点，这就是ABA问题。
>
> `循环时间长开销大`
>
> CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。
>
> `版本号法`
>
> 一般是在数据表中加上一个数据版本号 `version` 字段，表示数据被修改的次数。当数据被修改时，`version` 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 `version` 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 `version` 值相等时才更新，否则更新失败
>
> 版本号法并不会出现ABA问题

### volatile关键字

> 1. 保证可见性：`volatile` 关键字可以确保多个线程之间对被修饰变量的读取和写入操作具有可见性。当一个线程对 `volatile` 变量进行写操作时，它会立即刷新到主内存中，并且当其他线程读取该变量时，它们会从主内存中获取最新值，而不是使用自己线程工作内存中的副本。这样可以避免了线程间的数据不一致性问题。
> 2. 禁止指令重排序：`volatile` 关键字还可以防止编译器和处理器对被修饰变量的指令进行重排序。指令重排序是编译器和处理器为了优化程序性能而进行的一种优化手段，但在多线程环境下可能会导致意外的结果。通过使用 `volatile` 关键字，可以告诉编译器和处理器不要对被修饰变量的指令进行重排序，确保指令按照程序的原始顺序执行。

### ThreadLocal原理

>每个线程里都有自己的`ThreadLocal.ThreadLocalMap threadLocals`
>
>ThreadLocalMap 是ThreadLocal里的内部类
>
>ThreadLocalMap里有`Entry[] table`键值对数组，用来存放数据,key为ThreadLocal对象，value为ThreadLocal set的值
>
>![image-20230802160624958](https://raw.githubusercontent.com/njauwj/java-note/master/image-20230802160624958.png)

### 线程池的创建方式

> 1. 通过 **`Executors`** 工具类的静态方法创建线程池，底层用的也是 new ThreadPoolExecutor 
> 2. 通过`ThreadPoolExecutor`的构造方法创建线程池，自己手动指定参数（`推荐`）

### 线程池的参数

> ```java
>      public ThreadPoolExecutor(int corePoolSize,
>                               int maximumPoolSize,
>                               long keepAliveTime,
>                               TimeUnit unit,
>                               BlockingQueue<Runnable> workQueue,
>                               ThreadFactory threadFactory,
>                               RejectedExecutionHandler handler) {
> ```
>
> 最核心的三个参数：
>
> **`corePoolSize` :** 任务队列未达到队列容量时，最大可以同时运行的线程数量。
>
> **`maximumPoolSize` :** 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
>
> **`workQueue`:** 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。
>
> 如果没有达到，就会创建核心线程去处理该任务，当队列满时，核心线程数也满时才会创建非核心线程去处理任务
>
> 其他参数：
>
> **`keepAliveTime`**:线程池中的线程数量大于 `corePoolSize` 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime`才会被回收销毁；
>
> **`unit`** : `keepAliveTime` 参数的时间单位。
>
> **`threadFactory`** :主要作用是可以自定义线程的名称、优先级、是否为守护线程等属性
>
> **`handler`** :饱和策略。关于饱和策略下面单独介绍一下。
>
> ![image-20230802194856867](https://raw.githubusercontent.com/njauwj/java-note/master/image-20230802194856867.png)

### 线程池的饱和策略

> 当达到最大线程数，队列也已经满时采取的策略 ，实现该`RejectedExecutionHandler`接口的一个类
>
> 1. `ThreadPoolExecutor.AbortPolicy`（默认）：当工作队列和线程池都已满时，新提交的任务将被拒绝，并抛出`RejectedExecutionException`异常。
> 2. `ThreadPoolExecutor.CallerRunsPolicy`：当工作队列已满时，新提交的任务会在提交线程上执行。这意味着任务的提交线程会执行该任务，而不是交给线程池中的其他线程执行。这样可以降低提交速度，但是会降低整体系统吞吐量。
> 3. `ThreadPoolExecutor.DiscardPolicy`：当工作队列已满时，新提交的任务将被简单地丢弃，不会有任何异常抛出，也不会执行该任务。
> 4. `ThreadPoolExecutor.DiscardOldestPolicy`：当工作队列已满时，线程池会丢弃工作队列中最旧的一个任务，然后尝试再次提交当前任务。

### 线程池常用的阻塞队列

> 实现`BlockingQueue<Runnable> workQueue`接口的类，用于存储待执行的任务
>
> 1. `ArrayBlockingQueue`：基于数组实现的有界阻塞队列，必须指定队列的容量。当队列满时，新的任务将无法放入队列，直到有空位为止。
> 2. `LinkedBlockingQueue`：基于链表实现的可选有界或无界阻塞队列。如果没有指定容量，则默认是无界的。无界队列可能会导致内存溢出，因为它可以无限制地添加任务到队列中。
> 3. `PriorityBlockingQueue`：支持优先级的无界阻塞队列。任务会根据优先级进行排序，高优先级的任务优先被取出执行。
> 4. `SynchronousQueue`：一个没有数据缓冲的阻塞队列。每个插入操作必须等待一个相应的删除操作，反之亦然。它主要用于将生产者线程和消费者线程直接连接起来，以实现直接传递任务。
> 5. `DelayQueue`：支持延迟执行的无界阻塞队列。任务只有在其延迟时间到期时才能被取出执行。

### 线程池处理任务的流程

> 如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。
>
> 如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。
>
> 如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。
>
> 如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用`RejectedExecutionHandler.rejectedExecution()`方法
>
> ![image-20230802205550406](https://raw.githubusercontent.com/njauwj/java-note/master/image-20230802205550406.png)

## 十三、消息队列

### 什么是消息队列

> 消息队列（实现了`AMQP`协议）是一种用于在不同组件或系统之间传递消息的**通信模式**。它是一种基于异步通信的方式，发送方将消息发送到队列中，接收方从队列中获取消息进行处理。

### MQ的优缺点

> 优点：
>
> 1. `异步通信`：例如用户下单后发一条消息直接返回，不需要等待物流，库存，支付系统完成，只要保证数据最终的一致性即可，减少接口的响应时间。
> 2. `解耦`：一个服务挂了不应该影响其他服务，采用发布订阅模式而不是硬编码。
> 3. `削峰填谷`：消息队列可以平滑处理突发的请求压力，通过缓冲和调节消息处理速度，避免系统崩溃。
> 4. 可靠性和持久化：消息队列通常提供持久化机制，确保消息不会丢失，并具备消息传递的可靠性。
> 5. 异构系统集成：消息队列可以连接不同的系统(例如调用不同语言编写的服务），使得异构系统之间的通信更加简单和可靠。
> 6. 可恢复性：即使在系统故障或崩溃的情况下，消息队列可以保证消息的可靠传递和处理。
>
> 缺点：
>
> 1. 复杂性：需要保证数据的一致性，消息的重复消费，消息的可靠性等一系列问题
> 2. 数据一致性：例如A系统发消息，BCD系统消费，如果BCD有一个执行失败，就会出现数据不一致
> 3. 系统可用性降低：消息队列如果挂了，会影响整个系统的运行

### AMQP模型的组件

> 1. `Producer`（生产者）：负责创建并发送消息到消息队列。生产者将消息发送到指定的交换机（Exchange），并指定消息的路由键（Routing Key）。
> 2. `Exchange`（交换机）：接收来自生产者的消息，并根据指定的路由键将消息路由到一个或多个队列。交换机有不同的类型，包括直连交换机（Direct Exchange）、主题交换机（Topic Exchange）、扇形交换机（Fanout Exchange）和头部交换机（Headers Exchange）。
> 3. `Queue`（队列）：消息队列，用于存储待处理的消息。消费者从队列中获取消息进行处理。每个队列都有一个唯一的名称，并且可以绑定到一个或多个交换机。
> 4. `Binding`（绑定）：将交换机和队列进行绑定，指定特定的路由规则。绑定定义了交换机如何将消息路由到队列。
> 5. `Consumer`（消费者）：订阅队列中的消息，并进行处理。消费者从队列中获取消息，并根据自身的逻辑进行处理。
>
> 这些组件共同构成了一个完整的AMQP模型，实现了消息的生产、路由和消费的过程。生产者将消息发送到交换机，交换机根据路由规则将消息路由到队列，消费者从队列中获取消息进行处理。通过这种方式，AMQP模型实现了高效、可靠的消息传递机制。

### Rabbitmq的交换机类型

> 1. **`Direct Exchange`（直连交换机）：** 这是最简单的交换机类型。它将消息发送到与消息的路由键（Routing Key）完全匹配的队列。只有一个队列会收到消息。
>
>     ![direct 类型交换器](https://raw.githubusercontent.com/njauwj/java-note/master/37008021.jpg)
>
> 2. **`Fanout Exchange`（扇形交换机）：** 扇形交换机将消息广播到所有绑定到该交换机的队列。**它不考虑消息的路由键**，只需将队列绑定到交换机即可。适用于广播消息，需要使用的队列绑定该交换机即可。
>
> 3. **`Topic Exchange`（主题交换机）：** 主题交换机允许使用通配符匹配路由键，将消息发送到符合模式的队列。通配符可以使用*（一个词）或#（零个或多个词）来匹配路由键。
>
>     ![topic 类型交换器](https://raw.githubusercontent.com/njauwj/java-note/master/73843.jpg)

### Rabbitmq的死信队列

> `死信`顾名思义，就是死掉的信息，英文是Dead Letter。`死信交换机（Dead-Letter-Exchange）`和普通交换机没有区别，都是可以接受信息并转发到与之绑定并能路由到的队列，区别在于`死信交换机`是转发`死信`的，而和该`死信交换机`绑定的队列就是`死信队列`。说的再通俗一点，死信交换机和死信队列其实都只是普通的交换机和队列，只不过接受、转发的信息是`死信`，其他操作并没有区别。
>
> **成为死信的条件**
>
> 1. **消息被拒绝（Basic.Reject 或 Basic.Nack）且不再重新投递：** 当消费者在处理消息时发现无法处理，可以显式地拒绝该消息。如果设置了 `requeue` 参数为 `false`，则该消息将被标记为死信。
> 2. **消息在队列中过期：** 队列可以设置消息的过期时间，如果消息在队列中存留的时间超过了设置的过期时间，该消息会被标记为死信。
> 3. **队列达到最大长度：** 队列可以设置最大长度，当队列中的消息数量超过最大长度时，最早进入队列的消息会被标记为死信。
>
> ![image-20230805110542642](https://raw.githubusercontent.com/njauwj/java-note/master/image-20230805110542642.png)

### Rabbitmq消息的过期

> 1. 设置队列的过期时间
> 2. 为单条消息设置过期时间
>
> 两者都设置了的情况下以过期时间短的为准
>
> 绑定了死信交换机的时候，消息的过期时间要格外注意，如果前面的消息过期时间为10秒，后面的过期时间为5秒，后面的消息就算过期了也不会变成死信，因为队列是先进先出的。

### Rabbitmq消息的确认

> 消息的确认是为了确保消息在生产者和消费者之间的`可靠性`传递，分为两大块：
>
> `消息发送确认`
>
> 消息从生产者到交换机投递后触发`ConfirmCallback`回调函数，可以在回调函数里做相对应的处理，无论消息是否到交换机都会触发，并不是只有失败才会触发
>
> 消息从交换机到队列投递时触发`ReturnsCallback`回调函数，可以在回调函数里做相对应的处理，这个只有当消息从交换机到队列投递失败时才会触发，成功了是不会触发的
>
> `消息接受确认`
>
> ```java
> Channel接口里的方法
> // deliveryTag消息的唯一表示 multiple 为true可以批量处理这条消息之前的所有消息，假设你的消费者从 RabbitMQ 中获取了一批消息，然后在处理完这批消息后，你可以一次性确认所有消息，而不需要一个一个地确认。requeue 是否重新入队，不重新入队就会变成死信，如果配置了死信交换机和死信队列就会进入死信队列，没有配置消息就直接删除
> void basicAck(long deliveryTag, boolean multiple) //确认消息
> void basicNack(long deliveryTag, boolean multiple, boolean requeue)//不确认消息
> void basicReject(long deliveryTag, boolean requeue)// 拒绝消息
> ```
>
> ![消息可靠性投递方案一.jpg](https://raw.githubusercontent.com/njauwj/java-note/master/fab13603d68f4779904743ae26629432%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A4536%3A0%3A0%3A0.awebp)

### Rabbitmq的延迟队列

> 1. 使用死信队列实现延迟队列的效果
>
> 2. 开启延迟队列插件（默认是不开启的），开启后即可创建延迟交换机，消息发送后不会直接进入队列，而是保存到数据库，
>
>     等到延迟时间到了才会进入队列
>
> ![image-20230806144922183](https://raw.githubusercontent.com/njauwj/java-note/master/image-20230806144922183.png)
>
> ![image-20230806144506813](https://raw.githubusercontent.com/njauwj/java-note/master/image-20230806144506813.png)

### Rabbitmq集群

> `普通集群模式`
>
> 只复制元数据，不复制消息，元数据就是除了消息以外的内容，像交换机，队列这些信息
>
> 优点：节约磁盘空间
>
> 缺点：如果节点1挂了消息的发送与消费都无法进行
>
> ![image-20230806160723135](https://raw.githubusercontent.com/njauwj/java-note/master/image-20230806160723135.png)
>
> `镜像集群模式`
>
> 会复制所有的数据，节点1挂了也可以继续发消息消费消息

### 如何保证消息不被重复消费

> **消息重复消费可能出现的场景**
>
> 1. **网络抖动、连接问题：** 消费者在处理完消息后，还未发送确认（ack）给 RabbitMQ，网络中断或者连接问题导致确认没有及时到达，RabbitMQ 认为消息未被处理，会重新将消息发送给消费者。
> 2. **消费者异常退出：** 如果消费者在处理消息过程中发生异常退出，RabbitMQ 也会重新将该消息发送给其他消费者。
>
> **解决方法**
>
> 1. 每条消息都有自己的唯一标识，将处理过的消息的唯一标识存储起来用来判断消息是否被处理过。
> 2. 保证消费逻辑的幂等性，就是消息无论消费多少次结果都是一样，例如插入数据时做好唯一性判断
>
> 幂等性就是指执行一万次和一次产生的结果都是一样的





